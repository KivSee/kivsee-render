// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: functions.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_functions_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_functions_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_functions_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_functions_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[8]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_functions_2eproto;
class Comb2FloatFunctionConfig;
struct Comb2FloatFunctionConfigDefaultTypeInternal;
extern Comb2FloatFunctionConfigDefaultTypeInternal _Comb2FloatFunctionConfig_default_instance_;
class ConstValueFloatFunctionConfig;
struct ConstValueFloatFunctionConfigDefaultTypeInternal;
extern ConstValueFloatFunctionConfigDefaultTypeInternal _ConstValueFloatFunctionConfig_default_instance_;
class FloatFunction;
struct FloatFunctionDefaultTypeInternal;
extern FloatFunctionDefaultTypeInternal _FloatFunction_default_instance_;
class HalfFloatFunctionConfig;
struct HalfFloatFunctionConfigDefaultTypeInternal;
extern HalfFloatFunctionConfigDefaultTypeInternal _HalfFloatFunctionConfig_default_instance_;
class LinearFloatFunctionConfig;
struct LinearFloatFunctionConfigDefaultTypeInternal;
extern LinearFloatFunctionConfigDefaultTypeInternal _LinearFloatFunctionConfig_default_instance_;
class RepeatFloatFunctionConfig;
struct RepeatFloatFunctionConfigDefaultTypeInternal;
extern RepeatFloatFunctionConfigDefaultTypeInternal _RepeatFloatFunctionConfig_default_instance_;
class SinFloatFunctionConfig;
struct SinFloatFunctionConfigDefaultTypeInternal;
extern SinFloatFunctionConfigDefaultTypeInternal _SinFloatFunctionConfig_default_instance_;
class StepsFloatFunctionConfig;
struct StepsFloatFunctionConfigDefaultTypeInternal;
extern StepsFloatFunctionConfigDefaultTypeInternal _StepsFloatFunctionConfig_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::Comb2FloatFunctionConfig* Arena::CreateMaybeMessage<::Comb2FloatFunctionConfig>(Arena*);
template<> ::ConstValueFloatFunctionConfig* Arena::CreateMaybeMessage<::ConstValueFloatFunctionConfig>(Arena*);
template<> ::FloatFunction* Arena::CreateMaybeMessage<::FloatFunction>(Arena*);
template<> ::HalfFloatFunctionConfig* Arena::CreateMaybeMessage<::HalfFloatFunctionConfig>(Arena*);
template<> ::LinearFloatFunctionConfig* Arena::CreateMaybeMessage<::LinearFloatFunctionConfig>(Arena*);
template<> ::RepeatFloatFunctionConfig* Arena::CreateMaybeMessage<::RepeatFloatFunctionConfig>(Arena*);
template<> ::SinFloatFunctionConfig* Arena::CreateMaybeMessage<::SinFloatFunctionConfig>(Arena*);
template<> ::StepsFloatFunctionConfig* Arena::CreateMaybeMessage<::StepsFloatFunctionConfig>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

// ===================================================================

class ConstValueFloatFunctionConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ConstValueFloatFunctionConfig) */ {
 public:
  inline ConstValueFloatFunctionConfig() : ConstValueFloatFunctionConfig(nullptr) {}
  ~ConstValueFloatFunctionConfig() override;
  explicit constexpr ConstValueFloatFunctionConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConstValueFloatFunctionConfig(const ConstValueFloatFunctionConfig& from);
  ConstValueFloatFunctionConfig(ConstValueFloatFunctionConfig&& from) noexcept
    : ConstValueFloatFunctionConfig() {
    *this = ::std::move(from);
  }

  inline ConstValueFloatFunctionConfig& operator=(const ConstValueFloatFunctionConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConstValueFloatFunctionConfig& operator=(ConstValueFloatFunctionConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConstValueFloatFunctionConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConstValueFloatFunctionConfig* internal_default_instance() {
    return reinterpret_cast<const ConstValueFloatFunctionConfig*>(
               &_ConstValueFloatFunctionConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ConstValueFloatFunctionConfig& a, ConstValueFloatFunctionConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(ConstValueFloatFunctionConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConstValueFloatFunctionConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConstValueFloatFunctionConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConstValueFloatFunctionConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConstValueFloatFunctionConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ConstValueFloatFunctionConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConstValueFloatFunctionConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ConstValueFloatFunctionConfig";
  }
  protected:
  explicit ConstValueFloatFunctionConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // float value = 1;
  void clear_value();
  float value() const;
  void set_value(float value);
  private:
  float _internal_value() const;
  void _internal_set_value(float value);
  public:

  // @@protoc_insertion_point(class_scope:ConstValueFloatFunctionConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_functions_2eproto;
};
// -------------------------------------------------------------------

class LinearFloatFunctionConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:LinearFloatFunctionConfig) */ {
 public:
  inline LinearFloatFunctionConfig() : LinearFloatFunctionConfig(nullptr) {}
  ~LinearFloatFunctionConfig() override;
  explicit constexpr LinearFloatFunctionConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LinearFloatFunctionConfig(const LinearFloatFunctionConfig& from);
  LinearFloatFunctionConfig(LinearFloatFunctionConfig&& from) noexcept
    : LinearFloatFunctionConfig() {
    *this = ::std::move(from);
  }

  inline LinearFloatFunctionConfig& operator=(const LinearFloatFunctionConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline LinearFloatFunctionConfig& operator=(LinearFloatFunctionConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LinearFloatFunctionConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const LinearFloatFunctionConfig* internal_default_instance() {
    return reinterpret_cast<const LinearFloatFunctionConfig*>(
               &_LinearFloatFunctionConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(LinearFloatFunctionConfig& a, LinearFloatFunctionConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(LinearFloatFunctionConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LinearFloatFunctionConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LinearFloatFunctionConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LinearFloatFunctionConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LinearFloatFunctionConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LinearFloatFunctionConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LinearFloatFunctionConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "LinearFloatFunctionConfig";
  }
  protected:
  explicit LinearFloatFunctionConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartFieldNumber = 1,
    kEndFieldNumber = 2,
  };
  // float start = 1;
  void clear_start();
  float start() const;
  void set_start(float value);
  private:
  float _internal_start() const;
  void _internal_set_start(float value);
  public:

  // float end = 2;
  void clear_end();
  float end() const;
  void set_end(float value);
  private:
  float _internal_end() const;
  void _internal_set_end(float value);
  public:

  // @@protoc_insertion_point(class_scope:LinearFloatFunctionConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float start_;
  float end_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_functions_2eproto;
};
// -------------------------------------------------------------------

class SinFloatFunctionConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SinFloatFunctionConfig) */ {
 public:
  inline SinFloatFunctionConfig() : SinFloatFunctionConfig(nullptr) {}
  ~SinFloatFunctionConfig() override;
  explicit constexpr SinFloatFunctionConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SinFloatFunctionConfig(const SinFloatFunctionConfig& from);
  SinFloatFunctionConfig(SinFloatFunctionConfig&& from) noexcept
    : SinFloatFunctionConfig() {
    *this = ::std::move(from);
  }

  inline SinFloatFunctionConfig& operator=(const SinFloatFunctionConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline SinFloatFunctionConfig& operator=(SinFloatFunctionConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SinFloatFunctionConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const SinFloatFunctionConfig* internal_default_instance() {
    return reinterpret_cast<const SinFloatFunctionConfig*>(
               &_SinFloatFunctionConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SinFloatFunctionConfig& a, SinFloatFunctionConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(SinFloatFunctionConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SinFloatFunctionConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SinFloatFunctionConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SinFloatFunctionConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SinFloatFunctionConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SinFloatFunctionConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SinFloatFunctionConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SinFloatFunctionConfig";
  }
  protected:
  explicit SinFloatFunctionConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMinFieldNumber = 1,
    kMaxFieldNumber = 2,
    kPhaseFieldNumber = 3,
    kRepeatsFieldNumber = 4,
  };
  // float min = 1;
  void clear_min();
  float min() const;
  void set_min(float value);
  private:
  float _internal_min() const;
  void _internal_set_min(float value);
  public:

  // float max = 2;
  void clear_max();
  float max() const;
  void set_max(float value);
  private:
  float _internal_max() const;
  void _internal_set_max(float value);
  public:

  // float phase = 3;
  void clear_phase();
  float phase() const;
  void set_phase(float value);
  private:
  float _internal_phase() const;
  void _internal_set_phase(float value);
  public:

  // float repeats = 4;
  void clear_repeats();
  float repeats() const;
  void set_repeats(float value);
  private:
  float _internal_repeats() const;
  void _internal_set_repeats(float value);
  public:

  // @@protoc_insertion_point(class_scope:SinFloatFunctionConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float min_;
  float max_;
  float phase_;
  float repeats_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_functions_2eproto;
};
// -------------------------------------------------------------------

class StepsFloatFunctionConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StepsFloatFunctionConfig) */ {
 public:
  inline StepsFloatFunctionConfig() : StepsFloatFunctionConfig(nullptr) {}
  ~StepsFloatFunctionConfig() override;
  explicit constexpr StepsFloatFunctionConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StepsFloatFunctionConfig(const StepsFloatFunctionConfig& from);
  StepsFloatFunctionConfig(StepsFloatFunctionConfig&& from) noexcept
    : StepsFloatFunctionConfig() {
    *this = ::std::move(from);
  }

  inline StepsFloatFunctionConfig& operator=(const StepsFloatFunctionConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline StepsFloatFunctionConfig& operator=(StepsFloatFunctionConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StepsFloatFunctionConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const StepsFloatFunctionConfig* internal_default_instance() {
    return reinterpret_cast<const StepsFloatFunctionConfig*>(
               &_StepsFloatFunctionConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(StepsFloatFunctionConfig& a, StepsFloatFunctionConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(StepsFloatFunctionConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StepsFloatFunctionConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StepsFloatFunctionConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StepsFloatFunctionConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StepsFloatFunctionConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StepsFloatFunctionConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StepsFloatFunctionConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StepsFloatFunctionConfig";
  }
  protected:
  explicit StepsFloatFunctionConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNumStepsFieldNumber = 1,
    kDiffPerStepFieldNumber = 2,
    kFirstStepValueFieldNumber = 3,
  };
  // float num_steps = 1;
  void clear_num_steps();
  float num_steps() const;
  void set_num_steps(float value);
  private:
  float _internal_num_steps() const;
  void _internal_set_num_steps(float value);
  public:

  // float diff_per_step = 2;
  void clear_diff_per_step();
  float diff_per_step() const;
  void set_diff_per_step(float value);
  private:
  float _internal_diff_per_step() const;
  void _internal_set_diff_per_step(float value);
  public:

  // float first_step_value = 3;
  void clear_first_step_value();
  float first_step_value() const;
  void set_first_step_value(float value);
  private:
  float _internal_first_step_value() const;
  void _internal_set_first_step_value(float value);
  public:

  // @@protoc_insertion_point(class_scope:StepsFloatFunctionConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float num_steps_;
  float diff_per_step_;
  float first_step_value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_functions_2eproto;
};
// -------------------------------------------------------------------

class RepeatFloatFunctionConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RepeatFloatFunctionConfig) */ {
 public:
  inline RepeatFloatFunctionConfig() : RepeatFloatFunctionConfig(nullptr) {}
  ~RepeatFloatFunctionConfig() override;
  explicit constexpr RepeatFloatFunctionConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RepeatFloatFunctionConfig(const RepeatFloatFunctionConfig& from);
  RepeatFloatFunctionConfig(RepeatFloatFunctionConfig&& from) noexcept
    : RepeatFloatFunctionConfig() {
    *this = ::std::move(from);
  }

  inline RepeatFloatFunctionConfig& operator=(const RepeatFloatFunctionConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline RepeatFloatFunctionConfig& operator=(RepeatFloatFunctionConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RepeatFloatFunctionConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const RepeatFloatFunctionConfig* internal_default_instance() {
    return reinterpret_cast<const RepeatFloatFunctionConfig*>(
               &_RepeatFloatFunctionConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(RepeatFloatFunctionConfig& a, RepeatFloatFunctionConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(RepeatFloatFunctionConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RepeatFloatFunctionConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RepeatFloatFunctionConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RepeatFloatFunctionConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RepeatFloatFunctionConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RepeatFloatFunctionConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RepeatFloatFunctionConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RepeatFloatFunctionConfig";
  }
  protected:
  explicit RepeatFloatFunctionConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFuncToRepeatFieldNumber = 2,
    kNumberOfTimesFieldNumber = 1,
  };
  // .FloatFunction funcToRepeat = 2;
  bool has_functorepeat() const;
  private:
  bool _internal_has_functorepeat() const;
  public:
  void clear_functorepeat();
  const ::FloatFunction& functorepeat() const;
  PROTOBUF_NODISCARD ::FloatFunction* release_functorepeat();
  ::FloatFunction* mutable_functorepeat();
  void set_allocated_functorepeat(::FloatFunction* functorepeat);
  private:
  const ::FloatFunction& _internal_functorepeat() const;
  ::FloatFunction* _internal_mutable_functorepeat();
  public:
  void unsafe_arena_set_allocated_functorepeat(
      ::FloatFunction* functorepeat);
  ::FloatFunction* unsafe_arena_release_functorepeat();

  // float numberOfTimes = 1;
  void clear_numberoftimes();
  float numberoftimes() const;
  void set_numberoftimes(float value);
  private:
  float _internal_numberoftimes() const;
  void _internal_set_numberoftimes(float value);
  public:

  // @@protoc_insertion_point(class_scope:RepeatFloatFunctionConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::FloatFunction* functorepeat_;
  float numberoftimes_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_functions_2eproto;
};
// -------------------------------------------------------------------

class HalfFloatFunctionConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HalfFloatFunctionConfig) */ {
 public:
  inline HalfFloatFunctionConfig() : HalfFloatFunctionConfig(nullptr) {}
  ~HalfFloatFunctionConfig() override;
  explicit constexpr HalfFloatFunctionConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HalfFloatFunctionConfig(const HalfFloatFunctionConfig& from);
  HalfFloatFunctionConfig(HalfFloatFunctionConfig&& from) noexcept
    : HalfFloatFunctionConfig() {
    *this = ::std::move(from);
  }

  inline HalfFloatFunctionConfig& operator=(const HalfFloatFunctionConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline HalfFloatFunctionConfig& operator=(HalfFloatFunctionConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HalfFloatFunctionConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const HalfFloatFunctionConfig* internal_default_instance() {
    return reinterpret_cast<const HalfFloatFunctionConfig*>(
               &_HalfFloatFunctionConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(HalfFloatFunctionConfig& a, HalfFloatFunctionConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(HalfFloatFunctionConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HalfFloatFunctionConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HalfFloatFunctionConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HalfFloatFunctionConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HalfFloatFunctionConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const HalfFloatFunctionConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HalfFloatFunctionConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HalfFloatFunctionConfig";
  }
  protected:
  explicit HalfFloatFunctionConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kF1FieldNumber = 1,
    kF2FieldNumber = 2,
  };
  // .FloatFunction f1 = 1;
  bool has_f1() const;
  private:
  bool _internal_has_f1() const;
  public:
  void clear_f1();
  const ::FloatFunction& f1() const;
  PROTOBUF_NODISCARD ::FloatFunction* release_f1();
  ::FloatFunction* mutable_f1();
  void set_allocated_f1(::FloatFunction* f1);
  private:
  const ::FloatFunction& _internal_f1() const;
  ::FloatFunction* _internal_mutable_f1();
  public:
  void unsafe_arena_set_allocated_f1(
      ::FloatFunction* f1);
  ::FloatFunction* unsafe_arena_release_f1();

  // .FloatFunction f2 = 2;
  bool has_f2() const;
  private:
  bool _internal_has_f2() const;
  public:
  void clear_f2();
  const ::FloatFunction& f2() const;
  PROTOBUF_NODISCARD ::FloatFunction* release_f2();
  ::FloatFunction* mutable_f2();
  void set_allocated_f2(::FloatFunction* f2);
  private:
  const ::FloatFunction& _internal_f2() const;
  ::FloatFunction* _internal_mutable_f2();
  public:
  void unsafe_arena_set_allocated_f2(
      ::FloatFunction* f2);
  ::FloatFunction* unsafe_arena_release_f2();

  // @@protoc_insertion_point(class_scope:HalfFloatFunctionConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::FloatFunction* f1_;
  ::FloatFunction* f2_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_functions_2eproto;
};
// -------------------------------------------------------------------

class Comb2FloatFunctionConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Comb2FloatFunctionConfig) */ {
 public:
  inline Comb2FloatFunctionConfig() : Comb2FloatFunctionConfig(nullptr) {}
  ~Comb2FloatFunctionConfig() override;
  explicit constexpr Comb2FloatFunctionConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Comb2FloatFunctionConfig(const Comb2FloatFunctionConfig& from);
  Comb2FloatFunctionConfig(Comb2FloatFunctionConfig&& from) noexcept
    : Comb2FloatFunctionConfig() {
    *this = ::std::move(from);
  }

  inline Comb2FloatFunctionConfig& operator=(const Comb2FloatFunctionConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline Comb2FloatFunctionConfig& operator=(Comb2FloatFunctionConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Comb2FloatFunctionConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const Comb2FloatFunctionConfig* internal_default_instance() {
    return reinterpret_cast<const Comb2FloatFunctionConfig*>(
               &_Comb2FloatFunctionConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Comb2FloatFunctionConfig& a, Comb2FloatFunctionConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(Comb2FloatFunctionConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Comb2FloatFunctionConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Comb2FloatFunctionConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Comb2FloatFunctionConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Comb2FloatFunctionConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Comb2FloatFunctionConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Comb2FloatFunctionConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Comb2FloatFunctionConfig";
  }
  protected:
  explicit Comb2FloatFunctionConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kF1FieldNumber = 1,
    kF2FieldNumber = 3,
    kAmount1FieldNumber = 2,
    kAmount2FieldNumber = 4,
  };
  // .FloatFunction f1 = 1;
  bool has_f1() const;
  private:
  bool _internal_has_f1() const;
  public:
  void clear_f1();
  const ::FloatFunction& f1() const;
  PROTOBUF_NODISCARD ::FloatFunction* release_f1();
  ::FloatFunction* mutable_f1();
  void set_allocated_f1(::FloatFunction* f1);
  private:
  const ::FloatFunction& _internal_f1() const;
  ::FloatFunction* _internal_mutable_f1();
  public:
  void unsafe_arena_set_allocated_f1(
      ::FloatFunction* f1);
  ::FloatFunction* unsafe_arena_release_f1();

  // .FloatFunction f2 = 3;
  bool has_f2() const;
  private:
  bool _internal_has_f2() const;
  public:
  void clear_f2();
  const ::FloatFunction& f2() const;
  PROTOBUF_NODISCARD ::FloatFunction* release_f2();
  ::FloatFunction* mutable_f2();
  void set_allocated_f2(::FloatFunction* f2);
  private:
  const ::FloatFunction& _internal_f2() const;
  ::FloatFunction* _internal_mutable_f2();
  public:
  void unsafe_arena_set_allocated_f2(
      ::FloatFunction* f2);
  ::FloatFunction* unsafe_arena_release_f2();

  // float amount1 = 2;
  void clear_amount1();
  float amount1() const;
  void set_amount1(float value);
  private:
  float _internal_amount1() const;
  void _internal_set_amount1(float value);
  public:

  // float amount2 = 4;
  void clear_amount2();
  float amount2() const;
  void set_amount2(float value);
  private:
  float _internal_amount2() const;
  void _internal_set_amount2(float value);
  public:

  // @@protoc_insertion_point(class_scope:Comb2FloatFunctionConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::FloatFunction* f1_;
  ::FloatFunction* f2_;
  float amount1_;
  float amount2_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_functions_2eproto;
};
// -------------------------------------------------------------------

class FloatFunction final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:FloatFunction) */ {
 public:
  inline FloatFunction() : FloatFunction(nullptr) {}
  ~FloatFunction() override;
  explicit constexpr FloatFunction(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FloatFunction(const FloatFunction& from);
  FloatFunction(FloatFunction&& from) noexcept
    : FloatFunction() {
    *this = ::std::move(from);
  }

  inline FloatFunction& operator=(const FloatFunction& from) {
    CopyFrom(from);
    return *this;
  }
  inline FloatFunction& operator=(FloatFunction&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FloatFunction& default_instance() {
    return *internal_default_instance();
  }
  enum FunctionCase {
    kConstValue = 1,
    kLinear = 2,
    kSin = 3,
    kSteps = 4,
    kRepeat = 5,
    kHalf = 6,
    kComb2 = 7,
    FUNCTION_NOT_SET = 0,
  };

  static inline const FloatFunction* internal_default_instance() {
    return reinterpret_cast<const FloatFunction*>(
               &_FloatFunction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(FloatFunction& a, FloatFunction& b) {
    a.Swap(&b);
  }
  inline void Swap(FloatFunction* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FloatFunction* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FloatFunction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FloatFunction>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FloatFunction& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FloatFunction& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FloatFunction* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "FloatFunction";
  }
  protected:
  explicit FloatFunction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConstValueFieldNumber = 1,
    kLinearFieldNumber = 2,
    kSinFieldNumber = 3,
    kStepsFieldNumber = 4,
    kRepeatFieldNumber = 5,
    kHalfFieldNumber = 6,
    kComb2FieldNumber = 7,
  };
  // .ConstValueFloatFunctionConfig const_value = 1;
  bool has_const_value() const;
  private:
  bool _internal_has_const_value() const;
  public:
  void clear_const_value();
  const ::ConstValueFloatFunctionConfig& const_value() const;
  PROTOBUF_NODISCARD ::ConstValueFloatFunctionConfig* release_const_value();
  ::ConstValueFloatFunctionConfig* mutable_const_value();
  void set_allocated_const_value(::ConstValueFloatFunctionConfig* const_value);
  private:
  const ::ConstValueFloatFunctionConfig& _internal_const_value() const;
  ::ConstValueFloatFunctionConfig* _internal_mutable_const_value();
  public:
  void unsafe_arena_set_allocated_const_value(
      ::ConstValueFloatFunctionConfig* const_value);
  ::ConstValueFloatFunctionConfig* unsafe_arena_release_const_value();

  // .LinearFloatFunctionConfig linear = 2;
  bool has_linear() const;
  private:
  bool _internal_has_linear() const;
  public:
  void clear_linear();
  const ::LinearFloatFunctionConfig& linear() const;
  PROTOBUF_NODISCARD ::LinearFloatFunctionConfig* release_linear();
  ::LinearFloatFunctionConfig* mutable_linear();
  void set_allocated_linear(::LinearFloatFunctionConfig* linear);
  private:
  const ::LinearFloatFunctionConfig& _internal_linear() const;
  ::LinearFloatFunctionConfig* _internal_mutable_linear();
  public:
  void unsafe_arena_set_allocated_linear(
      ::LinearFloatFunctionConfig* linear);
  ::LinearFloatFunctionConfig* unsafe_arena_release_linear();

  // .SinFloatFunctionConfig sin = 3;
  bool has_sin() const;
  private:
  bool _internal_has_sin() const;
  public:
  void clear_sin();
  const ::SinFloatFunctionConfig& sin() const;
  PROTOBUF_NODISCARD ::SinFloatFunctionConfig* release_sin();
  ::SinFloatFunctionConfig* mutable_sin();
  void set_allocated_sin(::SinFloatFunctionConfig* sin);
  private:
  const ::SinFloatFunctionConfig& _internal_sin() const;
  ::SinFloatFunctionConfig* _internal_mutable_sin();
  public:
  void unsafe_arena_set_allocated_sin(
      ::SinFloatFunctionConfig* sin);
  ::SinFloatFunctionConfig* unsafe_arena_release_sin();

  // .StepsFloatFunctionConfig steps = 4;
  bool has_steps() const;
  private:
  bool _internal_has_steps() const;
  public:
  void clear_steps();
  const ::StepsFloatFunctionConfig& steps() const;
  PROTOBUF_NODISCARD ::StepsFloatFunctionConfig* release_steps();
  ::StepsFloatFunctionConfig* mutable_steps();
  void set_allocated_steps(::StepsFloatFunctionConfig* steps);
  private:
  const ::StepsFloatFunctionConfig& _internal_steps() const;
  ::StepsFloatFunctionConfig* _internal_mutable_steps();
  public:
  void unsafe_arena_set_allocated_steps(
      ::StepsFloatFunctionConfig* steps);
  ::StepsFloatFunctionConfig* unsafe_arena_release_steps();

  // .RepeatFloatFunctionConfig repeat = 5;
  bool has_repeat() const;
  private:
  bool _internal_has_repeat() const;
  public:
  void clear_repeat();
  const ::RepeatFloatFunctionConfig& repeat() const;
  PROTOBUF_NODISCARD ::RepeatFloatFunctionConfig* release_repeat();
  ::RepeatFloatFunctionConfig* mutable_repeat();
  void set_allocated_repeat(::RepeatFloatFunctionConfig* repeat);
  private:
  const ::RepeatFloatFunctionConfig& _internal_repeat() const;
  ::RepeatFloatFunctionConfig* _internal_mutable_repeat();
  public:
  void unsafe_arena_set_allocated_repeat(
      ::RepeatFloatFunctionConfig* repeat);
  ::RepeatFloatFunctionConfig* unsafe_arena_release_repeat();

  // .HalfFloatFunctionConfig half = 6;
  bool has_half() const;
  private:
  bool _internal_has_half() const;
  public:
  void clear_half();
  const ::HalfFloatFunctionConfig& half() const;
  PROTOBUF_NODISCARD ::HalfFloatFunctionConfig* release_half();
  ::HalfFloatFunctionConfig* mutable_half();
  void set_allocated_half(::HalfFloatFunctionConfig* half);
  private:
  const ::HalfFloatFunctionConfig& _internal_half() const;
  ::HalfFloatFunctionConfig* _internal_mutable_half();
  public:
  void unsafe_arena_set_allocated_half(
      ::HalfFloatFunctionConfig* half);
  ::HalfFloatFunctionConfig* unsafe_arena_release_half();

  // .Comb2FloatFunctionConfig comb2 = 7;
  bool has_comb2() const;
  private:
  bool _internal_has_comb2() const;
  public:
  void clear_comb2();
  const ::Comb2FloatFunctionConfig& comb2() const;
  PROTOBUF_NODISCARD ::Comb2FloatFunctionConfig* release_comb2();
  ::Comb2FloatFunctionConfig* mutable_comb2();
  void set_allocated_comb2(::Comb2FloatFunctionConfig* comb2);
  private:
  const ::Comb2FloatFunctionConfig& _internal_comb2() const;
  ::Comb2FloatFunctionConfig* _internal_mutable_comb2();
  public:
  void unsafe_arena_set_allocated_comb2(
      ::Comb2FloatFunctionConfig* comb2);
  ::Comb2FloatFunctionConfig* unsafe_arena_release_comb2();

  void clear_function();
  FunctionCase function_case() const;
  // @@protoc_insertion_point(class_scope:FloatFunction)
 private:
  class _Internal;
  void set_has_const_value();
  void set_has_linear();
  void set_has_sin();
  void set_has_steps();
  void set_has_repeat();
  void set_has_half();
  void set_has_comb2();

  inline bool has_function() const;
  inline void clear_has_function();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union FunctionUnion {
    constexpr FunctionUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::ConstValueFloatFunctionConfig* const_value_;
    ::LinearFloatFunctionConfig* linear_;
    ::SinFloatFunctionConfig* sin_;
    ::StepsFloatFunctionConfig* steps_;
    ::RepeatFloatFunctionConfig* repeat_;
    ::HalfFloatFunctionConfig* half_;
    ::Comb2FloatFunctionConfig* comb2_;
  } function_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_functions_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ConstValueFloatFunctionConfig

// float value = 1;
inline void ConstValueFloatFunctionConfig::clear_value() {
  value_ = 0;
}
inline float ConstValueFloatFunctionConfig::_internal_value() const {
  return value_;
}
inline float ConstValueFloatFunctionConfig::value() const {
  // @@protoc_insertion_point(field_get:ConstValueFloatFunctionConfig.value)
  return _internal_value();
}
inline void ConstValueFloatFunctionConfig::_internal_set_value(float value) {
  
  value_ = value;
}
inline void ConstValueFloatFunctionConfig::set_value(float value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:ConstValueFloatFunctionConfig.value)
}

// -------------------------------------------------------------------

// LinearFloatFunctionConfig

// float start = 1;
inline void LinearFloatFunctionConfig::clear_start() {
  start_ = 0;
}
inline float LinearFloatFunctionConfig::_internal_start() const {
  return start_;
}
inline float LinearFloatFunctionConfig::start() const {
  // @@protoc_insertion_point(field_get:LinearFloatFunctionConfig.start)
  return _internal_start();
}
inline void LinearFloatFunctionConfig::_internal_set_start(float value) {
  
  start_ = value;
}
inline void LinearFloatFunctionConfig::set_start(float value) {
  _internal_set_start(value);
  // @@protoc_insertion_point(field_set:LinearFloatFunctionConfig.start)
}

// float end = 2;
inline void LinearFloatFunctionConfig::clear_end() {
  end_ = 0;
}
inline float LinearFloatFunctionConfig::_internal_end() const {
  return end_;
}
inline float LinearFloatFunctionConfig::end() const {
  // @@protoc_insertion_point(field_get:LinearFloatFunctionConfig.end)
  return _internal_end();
}
inline void LinearFloatFunctionConfig::_internal_set_end(float value) {
  
  end_ = value;
}
inline void LinearFloatFunctionConfig::set_end(float value) {
  _internal_set_end(value);
  // @@protoc_insertion_point(field_set:LinearFloatFunctionConfig.end)
}

// -------------------------------------------------------------------

// SinFloatFunctionConfig

// float min = 1;
inline void SinFloatFunctionConfig::clear_min() {
  min_ = 0;
}
inline float SinFloatFunctionConfig::_internal_min() const {
  return min_;
}
inline float SinFloatFunctionConfig::min() const {
  // @@protoc_insertion_point(field_get:SinFloatFunctionConfig.min)
  return _internal_min();
}
inline void SinFloatFunctionConfig::_internal_set_min(float value) {
  
  min_ = value;
}
inline void SinFloatFunctionConfig::set_min(float value) {
  _internal_set_min(value);
  // @@protoc_insertion_point(field_set:SinFloatFunctionConfig.min)
}

// float max = 2;
inline void SinFloatFunctionConfig::clear_max() {
  max_ = 0;
}
inline float SinFloatFunctionConfig::_internal_max() const {
  return max_;
}
inline float SinFloatFunctionConfig::max() const {
  // @@protoc_insertion_point(field_get:SinFloatFunctionConfig.max)
  return _internal_max();
}
inline void SinFloatFunctionConfig::_internal_set_max(float value) {
  
  max_ = value;
}
inline void SinFloatFunctionConfig::set_max(float value) {
  _internal_set_max(value);
  // @@protoc_insertion_point(field_set:SinFloatFunctionConfig.max)
}

// float phase = 3;
inline void SinFloatFunctionConfig::clear_phase() {
  phase_ = 0;
}
inline float SinFloatFunctionConfig::_internal_phase() const {
  return phase_;
}
inline float SinFloatFunctionConfig::phase() const {
  // @@protoc_insertion_point(field_get:SinFloatFunctionConfig.phase)
  return _internal_phase();
}
inline void SinFloatFunctionConfig::_internal_set_phase(float value) {
  
  phase_ = value;
}
inline void SinFloatFunctionConfig::set_phase(float value) {
  _internal_set_phase(value);
  // @@protoc_insertion_point(field_set:SinFloatFunctionConfig.phase)
}

// float repeats = 4;
inline void SinFloatFunctionConfig::clear_repeats() {
  repeats_ = 0;
}
inline float SinFloatFunctionConfig::_internal_repeats() const {
  return repeats_;
}
inline float SinFloatFunctionConfig::repeats() const {
  // @@protoc_insertion_point(field_get:SinFloatFunctionConfig.repeats)
  return _internal_repeats();
}
inline void SinFloatFunctionConfig::_internal_set_repeats(float value) {
  
  repeats_ = value;
}
inline void SinFloatFunctionConfig::set_repeats(float value) {
  _internal_set_repeats(value);
  // @@protoc_insertion_point(field_set:SinFloatFunctionConfig.repeats)
}

// -------------------------------------------------------------------

// StepsFloatFunctionConfig

// float num_steps = 1;
inline void StepsFloatFunctionConfig::clear_num_steps() {
  num_steps_ = 0;
}
inline float StepsFloatFunctionConfig::_internal_num_steps() const {
  return num_steps_;
}
inline float StepsFloatFunctionConfig::num_steps() const {
  // @@protoc_insertion_point(field_get:StepsFloatFunctionConfig.num_steps)
  return _internal_num_steps();
}
inline void StepsFloatFunctionConfig::_internal_set_num_steps(float value) {
  
  num_steps_ = value;
}
inline void StepsFloatFunctionConfig::set_num_steps(float value) {
  _internal_set_num_steps(value);
  // @@protoc_insertion_point(field_set:StepsFloatFunctionConfig.num_steps)
}

// float diff_per_step = 2;
inline void StepsFloatFunctionConfig::clear_diff_per_step() {
  diff_per_step_ = 0;
}
inline float StepsFloatFunctionConfig::_internal_diff_per_step() const {
  return diff_per_step_;
}
inline float StepsFloatFunctionConfig::diff_per_step() const {
  // @@protoc_insertion_point(field_get:StepsFloatFunctionConfig.diff_per_step)
  return _internal_diff_per_step();
}
inline void StepsFloatFunctionConfig::_internal_set_diff_per_step(float value) {
  
  diff_per_step_ = value;
}
inline void StepsFloatFunctionConfig::set_diff_per_step(float value) {
  _internal_set_diff_per_step(value);
  // @@protoc_insertion_point(field_set:StepsFloatFunctionConfig.diff_per_step)
}

// float first_step_value = 3;
inline void StepsFloatFunctionConfig::clear_first_step_value() {
  first_step_value_ = 0;
}
inline float StepsFloatFunctionConfig::_internal_first_step_value() const {
  return first_step_value_;
}
inline float StepsFloatFunctionConfig::first_step_value() const {
  // @@protoc_insertion_point(field_get:StepsFloatFunctionConfig.first_step_value)
  return _internal_first_step_value();
}
inline void StepsFloatFunctionConfig::_internal_set_first_step_value(float value) {
  
  first_step_value_ = value;
}
inline void StepsFloatFunctionConfig::set_first_step_value(float value) {
  _internal_set_first_step_value(value);
  // @@protoc_insertion_point(field_set:StepsFloatFunctionConfig.first_step_value)
}

// -------------------------------------------------------------------

// RepeatFloatFunctionConfig

// float numberOfTimes = 1;
inline void RepeatFloatFunctionConfig::clear_numberoftimes() {
  numberoftimes_ = 0;
}
inline float RepeatFloatFunctionConfig::_internal_numberoftimes() const {
  return numberoftimes_;
}
inline float RepeatFloatFunctionConfig::numberoftimes() const {
  // @@protoc_insertion_point(field_get:RepeatFloatFunctionConfig.numberOfTimes)
  return _internal_numberoftimes();
}
inline void RepeatFloatFunctionConfig::_internal_set_numberoftimes(float value) {
  
  numberoftimes_ = value;
}
inline void RepeatFloatFunctionConfig::set_numberoftimes(float value) {
  _internal_set_numberoftimes(value);
  // @@protoc_insertion_point(field_set:RepeatFloatFunctionConfig.numberOfTimes)
}

// .FloatFunction funcToRepeat = 2;
inline bool RepeatFloatFunctionConfig::_internal_has_functorepeat() const {
  return this != internal_default_instance() && functorepeat_ != nullptr;
}
inline bool RepeatFloatFunctionConfig::has_functorepeat() const {
  return _internal_has_functorepeat();
}
inline void RepeatFloatFunctionConfig::clear_functorepeat() {
  if (GetArenaForAllocation() == nullptr && functorepeat_ != nullptr) {
    delete functorepeat_;
  }
  functorepeat_ = nullptr;
}
inline const ::FloatFunction& RepeatFloatFunctionConfig::_internal_functorepeat() const {
  const ::FloatFunction* p = functorepeat_;
  return p != nullptr ? *p : reinterpret_cast<const ::FloatFunction&>(
      ::_FloatFunction_default_instance_);
}
inline const ::FloatFunction& RepeatFloatFunctionConfig::functorepeat() const {
  // @@protoc_insertion_point(field_get:RepeatFloatFunctionConfig.funcToRepeat)
  return _internal_functorepeat();
}
inline void RepeatFloatFunctionConfig::unsafe_arena_set_allocated_functorepeat(
    ::FloatFunction* functorepeat) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(functorepeat_);
  }
  functorepeat_ = functorepeat;
  if (functorepeat) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RepeatFloatFunctionConfig.funcToRepeat)
}
inline ::FloatFunction* RepeatFloatFunctionConfig::release_functorepeat() {
  
  ::FloatFunction* temp = functorepeat_;
  functorepeat_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::FloatFunction* RepeatFloatFunctionConfig::unsafe_arena_release_functorepeat() {
  // @@protoc_insertion_point(field_release:RepeatFloatFunctionConfig.funcToRepeat)
  
  ::FloatFunction* temp = functorepeat_;
  functorepeat_ = nullptr;
  return temp;
}
inline ::FloatFunction* RepeatFloatFunctionConfig::_internal_mutable_functorepeat() {
  
  if (functorepeat_ == nullptr) {
    auto* p = CreateMaybeMessage<::FloatFunction>(GetArenaForAllocation());
    functorepeat_ = p;
  }
  return functorepeat_;
}
inline ::FloatFunction* RepeatFloatFunctionConfig::mutable_functorepeat() {
  ::FloatFunction* _msg = _internal_mutable_functorepeat();
  // @@protoc_insertion_point(field_mutable:RepeatFloatFunctionConfig.funcToRepeat)
  return _msg;
}
inline void RepeatFloatFunctionConfig::set_allocated_functorepeat(::FloatFunction* functorepeat) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete functorepeat_;
  }
  if (functorepeat) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::FloatFunction>::GetOwningArena(functorepeat);
    if (message_arena != submessage_arena) {
      functorepeat = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, functorepeat, submessage_arena);
    }
    
  } else {
    
  }
  functorepeat_ = functorepeat;
  // @@protoc_insertion_point(field_set_allocated:RepeatFloatFunctionConfig.funcToRepeat)
}

// -------------------------------------------------------------------

// HalfFloatFunctionConfig

// .FloatFunction f1 = 1;
inline bool HalfFloatFunctionConfig::_internal_has_f1() const {
  return this != internal_default_instance() && f1_ != nullptr;
}
inline bool HalfFloatFunctionConfig::has_f1() const {
  return _internal_has_f1();
}
inline void HalfFloatFunctionConfig::clear_f1() {
  if (GetArenaForAllocation() == nullptr && f1_ != nullptr) {
    delete f1_;
  }
  f1_ = nullptr;
}
inline const ::FloatFunction& HalfFloatFunctionConfig::_internal_f1() const {
  const ::FloatFunction* p = f1_;
  return p != nullptr ? *p : reinterpret_cast<const ::FloatFunction&>(
      ::_FloatFunction_default_instance_);
}
inline const ::FloatFunction& HalfFloatFunctionConfig::f1() const {
  // @@protoc_insertion_point(field_get:HalfFloatFunctionConfig.f1)
  return _internal_f1();
}
inline void HalfFloatFunctionConfig::unsafe_arena_set_allocated_f1(
    ::FloatFunction* f1) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(f1_);
  }
  f1_ = f1;
  if (f1) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HalfFloatFunctionConfig.f1)
}
inline ::FloatFunction* HalfFloatFunctionConfig::release_f1() {
  
  ::FloatFunction* temp = f1_;
  f1_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::FloatFunction* HalfFloatFunctionConfig::unsafe_arena_release_f1() {
  // @@protoc_insertion_point(field_release:HalfFloatFunctionConfig.f1)
  
  ::FloatFunction* temp = f1_;
  f1_ = nullptr;
  return temp;
}
inline ::FloatFunction* HalfFloatFunctionConfig::_internal_mutable_f1() {
  
  if (f1_ == nullptr) {
    auto* p = CreateMaybeMessage<::FloatFunction>(GetArenaForAllocation());
    f1_ = p;
  }
  return f1_;
}
inline ::FloatFunction* HalfFloatFunctionConfig::mutable_f1() {
  ::FloatFunction* _msg = _internal_mutable_f1();
  // @@protoc_insertion_point(field_mutable:HalfFloatFunctionConfig.f1)
  return _msg;
}
inline void HalfFloatFunctionConfig::set_allocated_f1(::FloatFunction* f1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete f1_;
  }
  if (f1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::FloatFunction>::GetOwningArena(f1);
    if (message_arena != submessage_arena) {
      f1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, f1, submessage_arena);
    }
    
  } else {
    
  }
  f1_ = f1;
  // @@protoc_insertion_point(field_set_allocated:HalfFloatFunctionConfig.f1)
}

// .FloatFunction f2 = 2;
inline bool HalfFloatFunctionConfig::_internal_has_f2() const {
  return this != internal_default_instance() && f2_ != nullptr;
}
inline bool HalfFloatFunctionConfig::has_f2() const {
  return _internal_has_f2();
}
inline void HalfFloatFunctionConfig::clear_f2() {
  if (GetArenaForAllocation() == nullptr && f2_ != nullptr) {
    delete f2_;
  }
  f2_ = nullptr;
}
inline const ::FloatFunction& HalfFloatFunctionConfig::_internal_f2() const {
  const ::FloatFunction* p = f2_;
  return p != nullptr ? *p : reinterpret_cast<const ::FloatFunction&>(
      ::_FloatFunction_default_instance_);
}
inline const ::FloatFunction& HalfFloatFunctionConfig::f2() const {
  // @@protoc_insertion_point(field_get:HalfFloatFunctionConfig.f2)
  return _internal_f2();
}
inline void HalfFloatFunctionConfig::unsafe_arena_set_allocated_f2(
    ::FloatFunction* f2) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(f2_);
  }
  f2_ = f2;
  if (f2) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HalfFloatFunctionConfig.f2)
}
inline ::FloatFunction* HalfFloatFunctionConfig::release_f2() {
  
  ::FloatFunction* temp = f2_;
  f2_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::FloatFunction* HalfFloatFunctionConfig::unsafe_arena_release_f2() {
  // @@protoc_insertion_point(field_release:HalfFloatFunctionConfig.f2)
  
  ::FloatFunction* temp = f2_;
  f2_ = nullptr;
  return temp;
}
inline ::FloatFunction* HalfFloatFunctionConfig::_internal_mutable_f2() {
  
  if (f2_ == nullptr) {
    auto* p = CreateMaybeMessage<::FloatFunction>(GetArenaForAllocation());
    f2_ = p;
  }
  return f2_;
}
inline ::FloatFunction* HalfFloatFunctionConfig::mutable_f2() {
  ::FloatFunction* _msg = _internal_mutable_f2();
  // @@protoc_insertion_point(field_mutable:HalfFloatFunctionConfig.f2)
  return _msg;
}
inline void HalfFloatFunctionConfig::set_allocated_f2(::FloatFunction* f2) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete f2_;
  }
  if (f2) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::FloatFunction>::GetOwningArena(f2);
    if (message_arena != submessage_arena) {
      f2 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, f2, submessage_arena);
    }
    
  } else {
    
  }
  f2_ = f2;
  // @@protoc_insertion_point(field_set_allocated:HalfFloatFunctionConfig.f2)
}

// -------------------------------------------------------------------

// Comb2FloatFunctionConfig

// .FloatFunction f1 = 1;
inline bool Comb2FloatFunctionConfig::_internal_has_f1() const {
  return this != internal_default_instance() && f1_ != nullptr;
}
inline bool Comb2FloatFunctionConfig::has_f1() const {
  return _internal_has_f1();
}
inline void Comb2FloatFunctionConfig::clear_f1() {
  if (GetArenaForAllocation() == nullptr && f1_ != nullptr) {
    delete f1_;
  }
  f1_ = nullptr;
}
inline const ::FloatFunction& Comb2FloatFunctionConfig::_internal_f1() const {
  const ::FloatFunction* p = f1_;
  return p != nullptr ? *p : reinterpret_cast<const ::FloatFunction&>(
      ::_FloatFunction_default_instance_);
}
inline const ::FloatFunction& Comb2FloatFunctionConfig::f1() const {
  // @@protoc_insertion_point(field_get:Comb2FloatFunctionConfig.f1)
  return _internal_f1();
}
inline void Comb2FloatFunctionConfig::unsafe_arena_set_allocated_f1(
    ::FloatFunction* f1) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(f1_);
  }
  f1_ = f1;
  if (f1) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Comb2FloatFunctionConfig.f1)
}
inline ::FloatFunction* Comb2FloatFunctionConfig::release_f1() {
  
  ::FloatFunction* temp = f1_;
  f1_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::FloatFunction* Comb2FloatFunctionConfig::unsafe_arena_release_f1() {
  // @@protoc_insertion_point(field_release:Comb2FloatFunctionConfig.f1)
  
  ::FloatFunction* temp = f1_;
  f1_ = nullptr;
  return temp;
}
inline ::FloatFunction* Comb2FloatFunctionConfig::_internal_mutable_f1() {
  
  if (f1_ == nullptr) {
    auto* p = CreateMaybeMessage<::FloatFunction>(GetArenaForAllocation());
    f1_ = p;
  }
  return f1_;
}
inline ::FloatFunction* Comb2FloatFunctionConfig::mutable_f1() {
  ::FloatFunction* _msg = _internal_mutable_f1();
  // @@protoc_insertion_point(field_mutable:Comb2FloatFunctionConfig.f1)
  return _msg;
}
inline void Comb2FloatFunctionConfig::set_allocated_f1(::FloatFunction* f1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete f1_;
  }
  if (f1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::FloatFunction>::GetOwningArena(f1);
    if (message_arena != submessage_arena) {
      f1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, f1, submessage_arena);
    }
    
  } else {
    
  }
  f1_ = f1;
  // @@protoc_insertion_point(field_set_allocated:Comb2FloatFunctionConfig.f1)
}

// float amount1 = 2;
inline void Comb2FloatFunctionConfig::clear_amount1() {
  amount1_ = 0;
}
inline float Comb2FloatFunctionConfig::_internal_amount1() const {
  return amount1_;
}
inline float Comb2FloatFunctionConfig::amount1() const {
  // @@protoc_insertion_point(field_get:Comb2FloatFunctionConfig.amount1)
  return _internal_amount1();
}
inline void Comb2FloatFunctionConfig::_internal_set_amount1(float value) {
  
  amount1_ = value;
}
inline void Comb2FloatFunctionConfig::set_amount1(float value) {
  _internal_set_amount1(value);
  // @@protoc_insertion_point(field_set:Comb2FloatFunctionConfig.amount1)
}

// .FloatFunction f2 = 3;
inline bool Comb2FloatFunctionConfig::_internal_has_f2() const {
  return this != internal_default_instance() && f2_ != nullptr;
}
inline bool Comb2FloatFunctionConfig::has_f2() const {
  return _internal_has_f2();
}
inline void Comb2FloatFunctionConfig::clear_f2() {
  if (GetArenaForAllocation() == nullptr && f2_ != nullptr) {
    delete f2_;
  }
  f2_ = nullptr;
}
inline const ::FloatFunction& Comb2FloatFunctionConfig::_internal_f2() const {
  const ::FloatFunction* p = f2_;
  return p != nullptr ? *p : reinterpret_cast<const ::FloatFunction&>(
      ::_FloatFunction_default_instance_);
}
inline const ::FloatFunction& Comb2FloatFunctionConfig::f2() const {
  // @@protoc_insertion_point(field_get:Comb2FloatFunctionConfig.f2)
  return _internal_f2();
}
inline void Comb2FloatFunctionConfig::unsafe_arena_set_allocated_f2(
    ::FloatFunction* f2) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(f2_);
  }
  f2_ = f2;
  if (f2) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Comb2FloatFunctionConfig.f2)
}
inline ::FloatFunction* Comb2FloatFunctionConfig::release_f2() {
  
  ::FloatFunction* temp = f2_;
  f2_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::FloatFunction* Comb2FloatFunctionConfig::unsafe_arena_release_f2() {
  // @@protoc_insertion_point(field_release:Comb2FloatFunctionConfig.f2)
  
  ::FloatFunction* temp = f2_;
  f2_ = nullptr;
  return temp;
}
inline ::FloatFunction* Comb2FloatFunctionConfig::_internal_mutable_f2() {
  
  if (f2_ == nullptr) {
    auto* p = CreateMaybeMessage<::FloatFunction>(GetArenaForAllocation());
    f2_ = p;
  }
  return f2_;
}
inline ::FloatFunction* Comb2FloatFunctionConfig::mutable_f2() {
  ::FloatFunction* _msg = _internal_mutable_f2();
  // @@protoc_insertion_point(field_mutable:Comb2FloatFunctionConfig.f2)
  return _msg;
}
inline void Comb2FloatFunctionConfig::set_allocated_f2(::FloatFunction* f2) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete f2_;
  }
  if (f2) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::FloatFunction>::GetOwningArena(f2);
    if (message_arena != submessage_arena) {
      f2 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, f2, submessage_arena);
    }
    
  } else {
    
  }
  f2_ = f2;
  // @@protoc_insertion_point(field_set_allocated:Comb2FloatFunctionConfig.f2)
}

// float amount2 = 4;
inline void Comb2FloatFunctionConfig::clear_amount2() {
  amount2_ = 0;
}
inline float Comb2FloatFunctionConfig::_internal_amount2() const {
  return amount2_;
}
inline float Comb2FloatFunctionConfig::amount2() const {
  // @@protoc_insertion_point(field_get:Comb2FloatFunctionConfig.amount2)
  return _internal_amount2();
}
inline void Comb2FloatFunctionConfig::_internal_set_amount2(float value) {
  
  amount2_ = value;
}
inline void Comb2FloatFunctionConfig::set_amount2(float value) {
  _internal_set_amount2(value);
  // @@protoc_insertion_point(field_set:Comb2FloatFunctionConfig.amount2)
}

// -------------------------------------------------------------------

// FloatFunction

// .ConstValueFloatFunctionConfig const_value = 1;
inline bool FloatFunction::_internal_has_const_value() const {
  return function_case() == kConstValue;
}
inline bool FloatFunction::has_const_value() const {
  return _internal_has_const_value();
}
inline void FloatFunction::set_has_const_value() {
  _oneof_case_[0] = kConstValue;
}
inline void FloatFunction::clear_const_value() {
  if (_internal_has_const_value()) {
    if (GetArenaForAllocation() == nullptr) {
      delete function_.const_value_;
    }
    clear_has_function();
  }
}
inline ::ConstValueFloatFunctionConfig* FloatFunction::release_const_value() {
  // @@protoc_insertion_point(field_release:FloatFunction.const_value)
  if (_internal_has_const_value()) {
    clear_has_function();
      ::ConstValueFloatFunctionConfig* temp = function_.const_value_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    function_.const_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ConstValueFloatFunctionConfig& FloatFunction::_internal_const_value() const {
  return _internal_has_const_value()
      ? *function_.const_value_
      : reinterpret_cast< ::ConstValueFloatFunctionConfig&>(::_ConstValueFloatFunctionConfig_default_instance_);
}
inline const ::ConstValueFloatFunctionConfig& FloatFunction::const_value() const {
  // @@protoc_insertion_point(field_get:FloatFunction.const_value)
  return _internal_const_value();
}
inline ::ConstValueFloatFunctionConfig* FloatFunction::unsafe_arena_release_const_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:FloatFunction.const_value)
  if (_internal_has_const_value()) {
    clear_has_function();
    ::ConstValueFloatFunctionConfig* temp = function_.const_value_;
    function_.const_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FloatFunction::unsafe_arena_set_allocated_const_value(::ConstValueFloatFunctionConfig* const_value) {
  clear_function();
  if (const_value) {
    set_has_const_value();
    function_.const_value_ = const_value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:FloatFunction.const_value)
}
inline ::ConstValueFloatFunctionConfig* FloatFunction::_internal_mutable_const_value() {
  if (!_internal_has_const_value()) {
    clear_function();
    set_has_const_value();
    function_.const_value_ = CreateMaybeMessage< ::ConstValueFloatFunctionConfig >(GetArenaForAllocation());
  }
  return function_.const_value_;
}
inline ::ConstValueFloatFunctionConfig* FloatFunction::mutable_const_value() {
  ::ConstValueFloatFunctionConfig* _msg = _internal_mutable_const_value();
  // @@protoc_insertion_point(field_mutable:FloatFunction.const_value)
  return _msg;
}

// .LinearFloatFunctionConfig linear = 2;
inline bool FloatFunction::_internal_has_linear() const {
  return function_case() == kLinear;
}
inline bool FloatFunction::has_linear() const {
  return _internal_has_linear();
}
inline void FloatFunction::set_has_linear() {
  _oneof_case_[0] = kLinear;
}
inline void FloatFunction::clear_linear() {
  if (_internal_has_linear()) {
    if (GetArenaForAllocation() == nullptr) {
      delete function_.linear_;
    }
    clear_has_function();
  }
}
inline ::LinearFloatFunctionConfig* FloatFunction::release_linear() {
  // @@protoc_insertion_point(field_release:FloatFunction.linear)
  if (_internal_has_linear()) {
    clear_has_function();
      ::LinearFloatFunctionConfig* temp = function_.linear_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    function_.linear_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::LinearFloatFunctionConfig& FloatFunction::_internal_linear() const {
  return _internal_has_linear()
      ? *function_.linear_
      : reinterpret_cast< ::LinearFloatFunctionConfig&>(::_LinearFloatFunctionConfig_default_instance_);
}
inline const ::LinearFloatFunctionConfig& FloatFunction::linear() const {
  // @@protoc_insertion_point(field_get:FloatFunction.linear)
  return _internal_linear();
}
inline ::LinearFloatFunctionConfig* FloatFunction::unsafe_arena_release_linear() {
  // @@protoc_insertion_point(field_unsafe_arena_release:FloatFunction.linear)
  if (_internal_has_linear()) {
    clear_has_function();
    ::LinearFloatFunctionConfig* temp = function_.linear_;
    function_.linear_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FloatFunction::unsafe_arena_set_allocated_linear(::LinearFloatFunctionConfig* linear) {
  clear_function();
  if (linear) {
    set_has_linear();
    function_.linear_ = linear;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:FloatFunction.linear)
}
inline ::LinearFloatFunctionConfig* FloatFunction::_internal_mutable_linear() {
  if (!_internal_has_linear()) {
    clear_function();
    set_has_linear();
    function_.linear_ = CreateMaybeMessage< ::LinearFloatFunctionConfig >(GetArenaForAllocation());
  }
  return function_.linear_;
}
inline ::LinearFloatFunctionConfig* FloatFunction::mutable_linear() {
  ::LinearFloatFunctionConfig* _msg = _internal_mutable_linear();
  // @@protoc_insertion_point(field_mutable:FloatFunction.linear)
  return _msg;
}

// .SinFloatFunctionConfig sin = 3;
inline bool FloatFunction::_internal_has_sin() const {
  return function_case() == kSin;
}
inline bool FloatFunction::has_sin() const {
  return _internal_has_sin();
}
inline void FloatFunction::set_has_sin() {
  _oneof_case_[0] = kSin;
}
inline void FloatFunction::clear_sin() {
  if (_internal_has_sin()) {
    if (GetArenaForAllocation() == nullptr) {
      delete function_.sin_;
    }
    clear_has_function();
  }
}
inline ::SinFloatFunctionConfig* FloatFunction::release_sin() {
  // @@protoc_insertion_point(field_release:FloatFunction.sin)
  if (_internal_has_sin()) {
    clear_has_function();
      ::SinFloatFunctionConfig* temp = function_.sin_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    function_.sin_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SinFloatFunctionConfig& FloatFunction::_internal_sin() const {
  return _internal_has_sin()
      ? *function_.sin_
      : reinterpret_cast< ::SinFloatFunctionConfig&>(::_SinFloatFunctionConfig_default_instance_);
}
inline const ::SinFloatFunctionConfig& FloatFunction::sin() const {
  // @@protoc_insertion_point(field_get:FloatFunction.sin)
  return _internal_sin();
}
inline ::SinFloatFunctionConfig* FloatFunction::unsafe_arena_release_sin() {
  // @@protoc_insertion_point(field_unsafe_arena_release:FloatFunction.sin)
  if (_internal_has_sin()) {
    clear_has_function();
    ::SinFloatFunctionConfig* temp = function_.sin_;
    function_.sin_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FloatFunction::unsafe_arena_set_allocated_sin(::SinFloatFunctionConfig* sin) {
  clear_function();
  if (sin) {
    set_has_sin();
    function_.sin_ = sin;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:FloatFunction.sin)
}
inline ::SinFloatFunctionConfig* FloatFunction::_internal_mutable_sin() {
  if (!_internal_has_sin()) {
    clear_function();
    set_has_sin();
    function_.sin_ = CreateMaybeMessage< ::SinFloatFunctionConfig >(GetArenaForAllocation());
  }
  return function_.sin_;
}
inline ::SinFloatFunctionConfig* FloatFunction::mutable_sin() {
  ::SinFloatFunctionConfig* _msg = _internal_mutable_sin();
  // @@protoc_insertion_point(field_mutable:FloatFunction.sin)
  return _msg;
}

// .StepsFloatFunctionConfig steps = 4;
inline bool FloatFunction::_internal_has_steps() const {
  return function_case() == kSteps;
}
inline bool FloatFunction::has_steps() const {
  return _internal_has_steps();
}
inline void FloatFunction::set_has_steps() {
  _oneof_case_[0] = kSteps;
}
inline void FloatFunction::clear_steps() {
  if (_internal_has_steps()) {
    if (GetArenaForAllocation() == nullptr) {
      delete function_.steps_;
    }
    clear_has_function();
  }
}
inline ::StepsFloatFunctionConfig* FloatFunction::release_steps() {
  // @@protoc_insertion_point(field_release:FloatFunction.steps)
  if (_internal_has_steps()) {
    clear_has_function();
      ::StepsFloatFunctionConfig* temp = function_.steps_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    function_.steps_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::StepsFloatFunctionConfig& FloatFunction::_internal_steps() const {
  return _internal_has_steps()
      ? *function_.steps_
      : reinterpret_cast< ::StepsFloatFunctionConfig&>(::_StepsFloatFunctionConfig_default_instance_);
}
inline const ::StepsFloatFunctionConfig& FloatFunction::steps() const {
  // @@protoc_insertion_point(field_get:FloatFunction.steps)
  return _internal_steps();
}
inline ::StepsFloatFunctionConfig* FloatFunction::unsafe_arena_release_steps() {
  // @@protoc_insertion_point(field_unsafe_arena_release:FloatFunction.steps)
  if (_internal_has_steps()) {
    clear_has_function();
    ::StepsFloatFunctionConfig* temp = function_.steps_;
    function_.steps_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FloatFunction::unsafe_arena_set_allocated_steps(::StepsFloatFunctionConfig* steps) {
  clear_function();
  if (steps) {
    set_has_steps();
    function_.steps_ = steps;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:FloatFunction.steps)
}
inline ::StepsFloatFunctionConfig* FloatFunction::_internal_mutable_steps() {
  if (!_internal_has_steps()) {
    clear_function();
    set_has_steps();
    function_.steps_ = CreateMaybeMessage< ::StepsFloatFunctionConfig >(GetArenaForAllocation());
  }
  return function_.steps_;
}
inline ::StepsFloatFunctionConfig* FloatFunction::mutable_steps() {
  ::StepsFloatFunctionConfig* _msg = _internal_mutable_steps();
  // @@protoc_insertion_point(field_mutable:FloatFunction.steps)
  return _msg;
}

// .RepeatFloatFunctionConfig repeat = 5;
inline bool FloatFunction::_internal_has_repeat() const {
  return function_case() == kRepeat;
}
inline bool FloatFunction::has_repeat() const {
  return _internal_has_repeat();
}
inline void FloatFunction::set_has_repeat() {
  _oneof_case_[0] = kRepeat;
}
inline void FloatFunction::clear_repeat() {
  if (_internal_has_repeat()) {
    if (GetArenaForAllocation() == nullptr) {
      delete function_.repeat_;
    }
    clear_has_function();
  }
}
inline ::RepeatFloatFunctionConfig* FloatFunction::release_repeat() {
  // @@protoc_insertion_point(field_release:FloatFunction.repeat)
  if (_internal_has_repeat()) {
    clear_has_function();
      ::RepeatFloatFunctionConfig* temp = function_.repeat_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    function_.repeat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::RepeatFloatFunctionConfig& FloatFunction::_internal_repeat() const {
  return _internal_has_repeat()
      ? *function_.repeat_
      : reinterpret_cast< ::RepeatFloatFunctionConfig&>(::_RepeatFloatFunctionConfig_default_instance_);
}
inline const ::RepeatFloatFunctionConfig& FloatFunction::repeat() const {
  // @@protoc_insertion_point(field_get:FloatFunction.repeat)
  return _internal_repeat();
}
inline ::RepeatFloatFunctionConfig* FloatFunction::unsafe_arena_release_repeat() {
  // @@protoc_insertion_point(field_unsafe_arena_release:FloatFunction.repeat)
  if (_internal_has_repeat()) {
    clear_has_function();
    ::RepeatFloatFunctionConfig* temp = function_.repeat_;
    function_.repeat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FloatFunction::unsafe_arena_set_allocated_repeat(::RepeatFloatFunctionConfig* repeat) {
  clear_function();
  if (repeat) {
    set_has_repeat();
    function_.repeat_ = repeat;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:FloatFunction.repeat)
}
inline ::RepeatFloatFunctionConfig* FloatFunction::_internal_mutable_repeat() {
  if (!_internal_has_repeat()) {
    clear_function();
    set_has_repeat();
    function_.repeat_ = CreateMaybeMessage< ::RepeatFloatFunctionConfig >(GetArenaForAllocation());
  }
  return function_.repeat_;
}
inline ::RepeatFloatFunctionConfig* FloatFunction::mutable_repeat() {
  ::RepeatFloatFunctionConfig* _msg = _internal_mutable_repeat();
  // @@protoc_insertion_point(field_mutable:FloatFunction.repeat)
  return _msg;
}

// .HalfFloatFunctionConfig half = 6;
inline bool FloatFunction::_internal_has_half() const {
  return function_case() == kHalf;
}
inline bool FloatFunction::has_half() const {
  return _internal_has_half();
}
inline void FloatFunction::set_has_half() {
  _oneof_case_[0] = kHalf;
}
inline void FloatFunction::clear_half() {
  if (_internal_has_half()) {
    if (GetArenaForAllocation() == nullptr) {
      delete function_.half_;
    }
    clear_has_function();
  }
}
inline ::HalfFloatFunctionConfig* FloatFunction::release_half() {
  // @@protoc_insertion_point(field_release:FloatFunction.half)
  if (_internal_has_half()) {
    clear_has_function();
      ::HalfFloatFunctionConfig* temp = function_.half_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    function_.half_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::HalfFloatFunctionConfig& FloatFunction::_internal_half() const {
  return _internal_has_half()
      ? *function_.half_
      : reinterpret_cast< ::HalfFloatFunctionConfig&>(::_HalfFloatFunctionConfig_default_instance_);
}
inline const ::HalfFloatFunctionConfig& FloatFunction::half() const {
  // @@protoc_insertion_point(field_get:FloatFunction.half)
  return _internal_half();
}
inline ::HalfFloatFunctionConfig* FloatFunction::unsafe_arena_release_half() {
  // @@protoc_insertion_point(field_unsafe_arena_release:FloatFunction.half)
  if (_internal_has_half()) {
    clear_has_function();
    ::HalfFloatFunctionConfig* temp = function_.half_;
    function_.half_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FloatFunction::unsafe_arena_set_allocated_half(::HalfFloatFunctionConfig* half) {
  clear_function();
  if (half) {
    set_has_half();
    function_.half_ = half;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:FloatFunction.half)
}
inline ::HalfFloatFunctionConfig* FloatFunction::_internal_mutable_half() {
  if (!_internal_has_half()) {
    clear_function();
    set_has_half();
    function_.half_ = CreateMaybeMessage< ::HalfFloatFunctionConfig >(GetArenaForAllocation());
  }
  return function_.half_;
}
inline ::HalfFloatFunctionConfig* FloatFunction::mutable_half() {
  ::HalfFloatFunctionConfig* _msg = _internal_mutable_half();
  // @@protoc_insertion_point(field_mutable:FloatFunction.half)
  return _msg;
}

// .Comb2FloatFunctionConfig comb2 = 7;
inline bool FloatFunction::_internal_has_comb2() const {
  return function_case() == kComb2;
}
inline bool FloatFunction::has_comb2() const {
  return _internal_has_comb2();
}
inline void FloatFunction::set_has_comb2() {
  _oneof_case_[0] = kComb2;
}
inline void FloatFunction::clear_comb2() {
  if (_internal_has_comb2()) {
    if (GetArenaForAllocation() == nullptr) {
      delete function_.comb2_;
    }
    clear_has_function();
  }
}
inline ::Comb2FloatFunctionConfig* FloatFunction::release_comb2() {
  // @@protoc_insertion_point(field_release:FloatFunction.comb2)
  if (_internal_has_comb2()) {
    clear_has_function();
      ::Comb2FloatFunctionConfig* temp = function_.comb2_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    function_.comb2_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Comb2FloatFunctionConfig& FloatFunction::_internal_comb2() const {
  return _internal_has_comb2()
      ? *function_.comb2_
      : reinterpret_cast< ::Comb2FloatFunctionConfig&>(::_Comb2FloatFunctionConfig_default_instance_);
}
inline const ::Comb2FloatFunctionConfig& FloatFunction::comb2() const {
  // @@protoc_insertion_point(field_get:FloatFunction.comb2)
  return _internal_comb2();
}
inline ::Comb2FloatFunctionConfig* FloatFunction::unsafe_arena_release_comb2() {
  // @@protoc_insertion_point(field_unsafe_arena_release:FloatFunction.comb2)
  if (_internal_has_comb2()) {
    clear_has_function();
    ::Comb2FloatFunctionConfig* temp = function_.comb2_;
    function_.comb2_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void FloatFunction::unsafe_arena_set_allocated_comb2(::Comb2FloatFunctionConfig* comb2) {
  clear_function();
  if (comb2) {
    set_has_comb2();
    function_.comb2_ = comb2;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:FloatFunction.comb2)
}
inline ::Comb2FloatFunctionConfig* FloatFunction::_internal_mutable_comb2() {
  if (!_internal_has_comb2()) {
    clear_function();
    set_has_comb2();
    function_.comb2_ = CreateMaybeMessage< ::Comb2FloatFunctionConfig >(GetArenaForAllocation());
  }
  return function_.comb2_;
}
inline ::Comb2FloatFunctionConfig* FloatFunction::mutable_comb2() {
  ::Comb2FloatFunctionConfig* _msg = _internal_mutable_comb2();
  // @@protoc_insertion_point(field_mutable:FloatFunction.comb2)
  return _msg;
}

inline bool FloatFunction::has_function() const {
  return function_case() != FUNCTION_NOT_SET;
}
inline void FloatFunction::clear_has_function() {
  _oneof_case_[0] = FUNCTION_NOT_SET;
}
inline FloatFunction::FunctionCase FloatFunction::function_case() const {
  return FloatFunction::FunctionCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_functions_2eproto
