// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: effects.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_effects_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_effects_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3014000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3014000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "functions.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_effects_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_effects_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[13]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_effects_2eproto;
class AlternateEffectConfig;
class AlternateEffectConfigDefaultTypeInternal;
extern AlternateEffectConfigDefaultTypeInternal _AlternateEffectConfig_default_instance_;
class AnimationProto;
class AnimationProtoDefaultTypeInternal;
extern AnimationProtoDefaultTypeInternal _AnimationProto_default_instance_;
class BrightnessEffectConfig;
class BrightnessEffectConfigDefaultTypeInternal;
extern BrightnessEffectConfigDefaultTypeInternal _BrightnessEffectConfig_default_instance_;
class ConstColorEffectConfig;
class ConstColorEffectConfigDefaultTypeInternal;
extern ConstColorEffectConfigDefaultTypeInternal _ConstColorEffectConfig_default_instance_;
class EffectConfig;
class EffectConfigDefaultTypeInternal;
extern EffectConfigDefaultTypeInternal _EffectConfig_default_instance_;
class EffectProto;
class EffectProtoDefaultTypeInternal;
extern EffectProtoDefaultTypeInternal _EffectProto_default_instance_;
class GlitterEffectConfig;
class GlitterEffectConfigDefaultTypeInternal;
extern GlitterEffectConfigDefaultTypeInternal _GlitterEffectConfig_default_instance_;
class HSV;
class HSVDefaultTypeInternal;
extern HSVDefaultTypeInternal _HSV_default_instance_;
class HueEffectConfig;
class HueEffectConfigDefaultTypeInternal;
extern HueEffectConfigDefaultTypeInternal _HueEffectConfig_default_instance_;
class RainbowEffectConfig;
class RainbowEffectConfigDefaultTypeInternal;
extern RainbowEffectConfigDefaultTypeInternal _RainbowEffectConfig_default_instance_;
class SaturationEffectConfig;
class SaturationEffectConfigDefaultTypeInternal;
extern SaturationEffectConfigDefaultTypeInternal _SaturationEffectConfig_default_instance_;
class SegmentEffectConfig;
class SegmentEffectConfigDefaultTypeInternal;
extern SegmentEffectConfigDefaultTypeInternal _SegmentEffectConfig_default_instance_;
class SnakeEffectConfig;
class SnakeEffectConfigDefaultTypeInternal;
extern SnakeEffectConfigDefaultTypeInternal _SnakeEffectConfig_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::AlternateEffectConfig* Arena::CreateMaybeMessage<::AlternateEffectConfig>(Arena*);
template<> ::AnimationProto* Arena::CreateMaybeMessage<::AnimationProto>(Arena*);
template<> ::BrightnessEffectConfig* Arena::CreateMaybeMessage<::BrightnessEffectConfig>(Arena*);
template<> ::ConstColorEffectConfig* Arena::CreateMaybeMessage<::ConstColorEffectConfig>(Arena*);
template<> ::EffectConfig* Arena::CreateMaybeMessage<::EffectConfig>(Arena*);
template<> ::EffectProto* Arena::CreateMaybeMessage<::EffectProto>(Arena*);
template<> ::GlitterEffectConfig* Arena::CreateMaybeMessage<::GlitterEffectConfig>(Arena*);
template<> ::HSV* Arena::CreateMaybeMessage<::HSV>(Arena*);
template<> ::HueEffectConfig* Arena::CreateMaybeMessage<::HueEffectConfig>(Arena*);
template<> ::RainbowEffectConfig* Arena::CreateMaybeMessage<::RainbowEffectConfig>(Arena*);
template<> ::SaturationEffectConfig* Arena::CreateMaybeMessage<::SaturationEffectConfig>(Arena*);
template<> ::SegmentEffectConfig* Arena::CreateMaybeMessage<::SegmentEffectConfig>(Arena*);
template<> ::SnakeEffectConfig* Arena::CreateMaybeMessage<::SnakeEffectConfig>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

// ===================================================================

class HSV PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HSV) */ {
 public:
  inline HSV() : HSV(nullptr) {}
  virtual ~HSV();

  HSV(const HSV& from);
  HSV(HSV&& from) noexcept
    : HSV() {
    *this = ::std::move(from);
  }

  inline HSV& operator=(const HSV& from) {
    CopyFrom(from);
    return *this;
  }
  inline HSV& operator=(HSV&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HSV& default_instance();

  static inline const HSV* internal_default_instance() {
    return reinterpret_cast<const HSV*>(
               &_HSV_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(HSV& a, HSV& b) {
    a.Swap(&b);
  }
  inline void Swap(HSV* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HSV* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HSV* New() const final {
    return CreateMaybeMessage<HSV>(nullptr);
  }

  HSV* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HSV>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HSV& from);
  void MergeFrom(const HSV& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HSV* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HSV";
  }
  protected:
  explicit HSV(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_effects_2eproto);
    return ::descriptor_table_effects_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHueFieldNumber = 1,
    kSatFieldNumber = 2,
    kValFieldNumber = 3,
  };
  // float hue = 1;
  void clear_hue();
  float hue() const;
  void set_hue(float value);
  private:
  float _internal_hue() const;
  void _internal_set_hue(float value);
  public:

  // float sat = 2;
  void clear_sat();
  float sat() const;
  void set_sat(float value);
  private:
  float _internal_sat() const;
  void _internal_set_sat(float value);
  public:

  // float val = 3;
  void clear_val();
  float val() const;
  void set_val(float value);
  private:
  float _internal_val() const;
  void _internal_set_val(float value);
  public:

  // @@protoc_insertion_point(class_scope:HSV)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float hue_;
  float sat_;
  float val_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_effects_2eproto;
};
// -------------------------------------------------------------------

class ConstColorEffectConfig PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ConstColorEffectConfig) */ {
 public:
  inline ConstColorEffectConfig() : ConstColorEffectConfig(nullptr) {}
  virtual ~ConstColorEffectConfig();

  ConstColorEffectConfig(const ConstColorEffectConfig& from);
  ConstColorEffectConfig(ConstColorEffectConfig&& from) noexcept
    : ConstColorEffectConfig() {
    *this = ::std::move(from);
  }

  inline ConstColorEffectConfig& operator=(const ConstColorEffectConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConstColorEffectConfig& operator=(ConstColorEffectConfig&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ConstColorEffectConfig& default_instance();

  static inline const ConstColorEffectConfig* internal_default_instance() {
    return reinterpret_cast<const ConstColorEffectConfig*>(
               &_ConstColorEffectConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ConstColorEffectConfig& a, ConstColorEffectConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(ConstColorEffectConfig* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConstColorEffectConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ConstColorEffectConfig* New() const final {
    return CreateMaybeMessage<ConstColorEffectConfig>(nullptr);
  }

  ConstColorEffectConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ConstColorEffectConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ConstColorEffectConfig& from);
  void MergeFrom(const ConstColorEffectConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConstColorEffectConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ConstColorEffectConfig";
  }
  protected:
  explicit ConstColorEffectConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_effects_2eproto);
    return ::descriptor_table_effects_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColorFieldNumber = 1,
  };
  // .HSV color = 1;
  bool has_color() const;
  private:
  bool _internal_has_color() const;
  public:
  void clear_color();
  const ::HSV& color() const;
  ::HSV* release_color();
  ::HSV* mutable_color();
  void set_allocated_color(::HSV* color);
  private:
  const ::HSV& _internal_color() const;
  ::HSV* _internal_mutable_color();
  public:
  void unsafe_arena_set_allocated_color(
      ::HSV* color);
  ::HSV* unsafe_arena_release_color();

  // @@protoc_insertion_point(class_scope:ConstColorEffectConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::HSV* color_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_effects_2eproto;
};
// -------------------------------------------------------------------

class RainbowEffectConfig PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RainbowEffectConfig) */ {
 public:
  inline RainbowEffectConfig() : RainbowEffectConfig(nullptr) {}
  virtual ~RainbowEffectConfig();

  RainbowEffectConfig(const RainbowEffectConfig& from);
  RainbowEffectConfig(RainbowEffectConfig&& from) noexcept
    : RainbowEffectConfig() {
    *this = ::std::move(from);
  }

  inline RainbowEffectConfig& operator=(const RainbowEffectConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline RainbowEffectConfig& operator=(RainbowEffectConfig&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const RainbowEffectConfig& default_instance();

  static inline const RainbowEffectConfig* internal_default_instance() {
    return reinterpret_cast<const RainbowEffectConfig*>(
               &_RainbowEffectConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RainbowEffectConfig& a, RainbowEffectConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(RainbowEffectConfig* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RainbowEffectConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RainbowEffectConfig* New() const final {
    return CreateMaybeMessage<RainbowEffectConfig>(nullptr);
  }

  RainbowEffectConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RainbowEffectConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const RainbowEffectConfig& from);
  void MergeFrom(const RainbowEffectConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RainbowEffectConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RainbowEffectConfig";
  }
  protected:
  explicit RainbowEffectConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_effects_2eproto);
    return ::descriptor_table_effects_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHueStartFieldNumber = 1,
    kHueEndFieldNumber = 2,
  };
  // .FloatFunction hue_start = 1;
  bool has_hue_start() const;
  private:
  bool _internal_has_hue_start() const;
  public:
  void clear_hue_start();
  const ::FloatFunction& hue_start() const;
  ::FloatFunction* release_hue_start();
  ::FloatFunction* mutable_hue_start();
  void set_allocated_hue_start(::FloatFunction* hue_start);
  private:
  const ::FloatFunction& _internal_hue_start() const;
  ::FloatFunction* _internal_mutable_hue_start();
  public:
  void unsafe_arena_set_allocated_hue_start(
      ::FloatFunction* hue_start);
  ::FloatFunction* unsafe_arena_release_hue_start();

  // .FloatFunction hue_end = 2;
  bool has_hue_end() const;
  private:
  bool _internal_has_hue_end() const;
  public:
  void clear_hue_end();
  const ::FloatFunction& hue_end() const;
  ::FloatFunction* release_hue_end();
  ::FloatFunction* mutable_hue_end();
  void set_allocated_hue_end(::FloatFunction* hue_end);
  private:
  const ::FloatFunction& _internal_hue_end() const;
  ::FloatFunction* _internal_mutable_hue_end();
  public:
  void unsafe_arena_set_allocated_hue_end(
      ::FloatFunction* hue_end);
  ::FloatFunction* unsafe_arena_release_hue_end();

  // @@protoc_insertion_point(class_scope:RainbowEffectConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::FloatFunction* hue_start_;
  ::FloatFunction* hue_end_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_effects_2eproto;
};
// -------------------------------------------------------------------

class BrightnessEffectConfig PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:BrightnessEffectConfig) */ {
 public:
  inline BrightnessEffectConfig() : BrightnessEffectConfig(nullptr) {}
  virtual ~BrightnessEffectConfig();

  BrightnessEffectConfig(const BrightnessEffectConfig& from);
  BrightnessEffectConfig(BrightnessEffectConfig&& from) noexcept
    : BrightnessEffectConfig() {
    *this = ::std::move(from);
  }

  inline BrightnessEffectConfig& operator=(const BrightnessEffectConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline BrightnessEffectConfig& operator=(BrightnessEffectConfig&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const BrightnessEffectConfig& default_instance();

  static inline const BrightnessEffectConfig* internal_default_instance() {
    return reinterpret_cast<const BrightnessEffectConfig*>(
               &_BrightnessEffectConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(BrightnessEffectConfig& a, BrightnessEffectConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(BrightnessEffectConfig* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BrightnessEffectConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BrightnessEffectConfig* New() const final {
    return CreateMaybeMessage<BrightnessEffectConfig>(nullptr);
  }

  BrightnessEffectConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BrightnessEffectConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const BrightnessEffectConfig& from);
  void MergeFrom(const BrightnessEffectConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BrightnessEffectConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "BrightnessEffectConfig";
  }
  protected:
  explicit BrightnessEffectConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_effects_2eproto);
    return ::descriptor_table_effects_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMultFactorFieldNumber = 1,
  };
  // .FloatFunction mult_factor = 1;
  bool has_mult_factor() const;
  private:
  bool _internal_has_mult_factor() const;
  public:
  void clear_mult_factor();
  const ::FloatFunction& mult_factor() const;
  ::FloatFunction* release_mult_factor();
  ::FloatFunction* mutable_mult_factor();
  void set_allocated_mult_factor(::FloatFunction* mult_factor);
  private:
  const ::FloatFunction& _internal_mult_factor() const;
  ::FloatFunction* _internal_mutable_mult_factor();
  public:
  void unsafe_arena_set_allocated_mult_factor(
      ::FloatFunction* mult_factor);
  ::FloatFunction* unsafe_arena_release_mult_factor();

  // @@protoc_insertion_point(class_scope:BrightnessEffectConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::FloatFunction* mult_factor_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_effects_2eproto;
};
// -------------------------------------------------------------------

class HueEffectConfig PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HueEffectConfig) */ {
 public:
  inline HueEffectConfig() : HueEffectConfig(nullptr) {}
  virtual ~HueEffectConfig();

  HueEffectConfig(const HueEffectConfig& from);
  HueEffectConfig(HueEffectConfig&& from) noexcept
    : HueEffectConfig() {
    *this = ::std::move(from);
  }

  inline HueEffectConfig& operator=(const HueEffectConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline HueEffectConfig& operator=(HueEffectConfig&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const HueEffectConfig& default_instance();

  static inline const HueEffectConfig* internal_default_instance() {
    return reinterpret_cast<const HueEffectConfig*>(
               &_HueEffectConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(HueEffectConfig& a, HueEffectConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(HueEffectConfig* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HueEffectConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HueEffectConfig* New() const final {
    return CreateMaybeMessage<HueEffectConfig>(nullptr);
  }

  HueEffectConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HueEffectConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const HueEffectConfig& from);
  void MergeFrom(const HueEffectConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HueEffectConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HueEffectConfig";
  }
  protected:
  explicit HueEffectConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_effects_2eproto);
    return ::descriptor_table_effects_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOffsetFactorFieldNumber = 1,
  };
  // .FloatFunction offset_factor = 1;
  bool has_offset_factor() const;
  private:
  bool _internal_has_offset_factor() const;
  public:
  void clear_offset_factor();
  const ::FloatFunction& offset_factor() const;
  ::FloatFunction* release_offset_factor();
  ::FloatFunction* mutable_offset_factor();
  void set_allocated_offset_factor(::FloatFunction* offset_factor);
  private:
  const ::FloatFunction& _internal_offset_factor() const;
  ::FloatFunction* _internal_mutable_offset_factor();
  public:
  void unsafe_arena_set_allocated_offset_factor(
      ::FloatFunction* offset_factor);
  ::FloatFunction* unsafe_arena_release_offset_factor();

  // @@protoc_insertion_point(class_scope:HueEffectConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::FloatFunction* offset_factor_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_effects_2eproto;
};
// -------------------------------------------------------------------

class SaturationEffectConfig PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SaturationEffectConfig) */ {
 public:
  inline SaturationEffectConfig() : SaturationEffectConfig(nullptr) {}
  virtual ~SaturationEffectConfig();

  SaturationEffectConfig(const SaturationEffectConfig& from);
  SaturationEffectConfig(SaturationEffectConfig&& from) noexcept
    : SaturationEffectConfig() {
    *this = ::std::move(from);
  }

  inline SaturationEffectConfig& operator=(const SaturationEffectConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline SaturationEffectConfig& operator=(SaturationEffectConfig&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SaturationEffectConfig& default_instance();

  static inline const SaturationEffectConfig* internal_default_instance() {
    return reinterpret_cast<const SaturationEffectConfig*>(
               &_SaturationEffectConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SaturationEffectConfig& a, SaturationEffectConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(SaturationEffectConfig* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SaturationEffectConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SaturationEffectConfig* New() const final {
    return CreateMaybeMessage<SaturationEffectConfig>(nullptr);
  }

  SaturationEffectConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SaturationEffectConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SaturationEffectConfig& from);
  void MergeFrom(const SaturationEffectConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SaturationEffectConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SaturationEffectConfig";
  }
  protected:
  explicit SaturationEffectConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_effects_2eproto);
    return ::descriptor_table_effects_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMultFactorFieldNumber = 1,
  };
  // .FloatFunction mult_factor = 1;
  bool has_mult_factor() const;
  private:
  bool _internal_has_mult_factor() const;
  public:
  void clear_mult_factor();
  const ::FloatFunction& mult_factor() const;
  ::FloatFunction* release_mult_factor();
  ::FloatFunction* mutable_mult_factor();
  void set_allocated_mult_factor(::FloatFunction* mult_factor);
  private:
  const ::FloatFunction& _internal_mult_factor() const;
  ::FloatFunction* _internal_mutable_mult_factor();
  public:
  void unsafe_arena_set_allocated_mult_factor(
      ::FloatFunction* mult_factor);
  ::FloatFunction* unsafe_arena_release_mult_factor();

  // @@protoc_insertion_point(class_scope:SaturationEffectConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::FloatFunction* mult_factor_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_effects_2eproto;
};
// -------------------------------------------------------------------

class SegmentEffectConfig PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SegmentEffectConfig) */ {
 public:
  inline SegmentEffectConfig() : SegmentEffectConfig(nullptr) {}
  virtual ~SegmentEffectConfig();

  SegmentEffectConfig(const SegmentEffectConfig& from);
  SegmentEffectConfig(SegmentEffectConfig&& from) noexcept
    : SegmentEffectConfig() {
    *this = ::std::move(from);
  }

  inline SegmentEffectConfig& operator=(const SegmentEffectConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline SegmentEffectConfig& operator=(SegmentEffectConfig&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SegmentEffectConfig& default_instance();

  static inline const SegmentEffectConfig* internal_default_instance() {
    return reinterpret_cast<const SegmentEffectConfig*>(
               &_SegmentEffectConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SegmentEffectConfig& a, SegmentEffectConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(SegmentEffectConfig* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SegmentEffectConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SegmentEffectConfig* New() const final {
    return CreateMaybeMessage<SegmentEffectConfig>(nullptr);
  }

  SegmentEffectConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SegmentEffectConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SegmentEffectConfig& from);
  void MergeFrom(const SegmentEffectConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SegmentEffectConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SegmentEffectConfig";
  }
  protected:
  explicit SegmentEffectConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_effects_2eproto);
    return ::descriptor_table_effects_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartFieldNumber = 1,
    kEndFieldNumber = 2,
  };
  // .FloatFunction start = 1;
  bool has_start() const;
  private:
  bool _internal_has_start() const;
  public:
  void clear_start();
  const ::FloatFunction& start() const;
  ::FloatFunction* release_start();
  ::FloatFunction* mutable_start();
  void set_allocated_start(::FloatFunction* start);
  private:
  const ::FloatFunction& _internal_start() const;
  ::FloatFunction* _internal_mutable_start();
  public:
  void unsafe_arena_set_allocated_start(
      ::FloatFunction* start);
  ::FloatFunction* unsafe_arena_release_start();

  // .FloatFunction end = 2;
  bool has_end() const;
  private:
  bool _internal_has_end() const;
  public:
  void clear_end();
  const ::FloatFunction& end() const;
  ::FloatFunction* release_end();
  ::FloatFunction* mutable_end();
  void set_allocated_end(::FloatFunction* end);
  private:
  const ::FloatFunction& _internal_end() const;
  ::FloatFunction* _internal_mutable_end();
  public:
  void unsafe_arena_set_allocated_end(
      ::FloatFunction* end);
  ::FloatFunction* unsafe_arena_release_end();

  // @@protoc_insertion_point(class_scope:SegmentEffectConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::FloatFunction* start_;
  ::FloatFunction* end_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_effects_2eproto;
};
// -------------------------------------------------------------------

class GlitterEffectConfig PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GlitterEffectConfig) */ {
 public:
  inline GlitterEffectConfig() : GlitterEffectConfig(nullptr) {}
  virtual ~GlitterEffectConfig();

  GlitterEffectConfig(const GlitterEffectConfig& from);
  GlitterEffectConfig(GlitterEffectConfig&& from) noexcept
    : GlitterEffectConfig() {
    *this = ::std::move(from);
  }

  inline GlitterEffectConfig& operator=(const GlitterEffectConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline GlitterEffectConfig& operator=(GlitterEffectConfig&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GlitterEffectConfig& default_instance();

  static inline const GlitterEffectConfig* internal_default_instance() {
    return reinterpret_cast<const GlitterEffectConfig*>(
               &_GlitterEffectConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(GlitterEffectConfig& a, GlitterEffectConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(GlitterEffectConfig* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GlitterEffectConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GlitterEffectConfig* New() const final {
    return CreateMaybeMessage<GlitterEffectConfig>(nullptr);
  }

  GlitterEffectConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GlitterEffectConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GlitterEffectConfig& from);
  void MergeFrom(const GlitterEffectConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GlitterEffectConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GlitterEffectConfig";
  }
  protected:
  explicit GlitterEffectConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_effects_2eproto);
    return ::descriptor_table_effects_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIntensityFieldNumber = 1,
    kSatMultFactorFieldNumber = 2,
  };
  // .FloatFunction intensity = 1;
  bool has_intensity() const;
  private:
  bool _internal_has_intensity() const;
  public:
  void clear_intensity();
  const ::FloatFunction& intensity() const;
  ::FloatFunction* release_intensity();
  ::FloatFunction* mutable_intensity();
  void set_allocated_intensity(::FloatFunction* intensity);
  private:
  const ::FloatFunction& _internal_intensity() const;
  ::FloatFunction* _internal_mutable_intensity();
  public:
  void unsafe_arena_set_allocated_intensity(
      ::FloatFunction* intensity);
  ::FloatFunction* unsafe_arena_release_intensity();

  // .FloatFunction sat_mult_factor = 2;
  bool has_sat_mult_factor() const;
  private:
  bool _internal_has_sat_mult_factor() const;
  public:
  void clear_sat_mult_factor();
  const ::FloatFunction& sat_mult_factor() const;
  ::FloatFunction* release_sat_mult_factor();
  ::FloatFunction* mutable_sat_mult_factor();
  void set_allocated_sat_mult_factor(::FloatFunction* sat_mult_factor);
  private:
  const ::FloatFunction& _internal_sat_mult_factor() const;
  ::FloatFunction* _internal_mutable_sat_mult_factor();
  public:
  void unsafe_arena_set_allocated_sat_mult_factor(
      ::FloatFunction* sat_mult_factor);
  ::FloatFunction* unsafe_arena_release_sat_mult_factor();

  // @@protoc_insertion_point(class_scope:GlitterEffectConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::FloatFunction* intensity_;
  ::FloatFunction* sat_mult_factor_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_effects_2eproto;
};
// -------------------------------------------------------------------

class SnakeEffectConfig PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SnakeEffectConfig) */ {
 public:
  inline SnakeEffectConfig() : SnakeEffectConfig(nullptr) {}
  virtual ~SnakeEffectConfig();

  SnakeEffectConfig(const SnakeEffectConfig& from);
  SnakeEffectConfig(SnakeEffectConfig&& from) noexcept
    : SnakeEffectConfig() {
    *this = ::std::move(from);
  }

  inline SnakeEffectConfig& operator=(const SnakeEffectConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline SnakeEffectConfig& operator=(SnakeEffectConfig&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const SnakeEffectConfig& default_instance();

  static inline const SnakeEffectConfig* internal_default_instance() {
    return reinterpret_cast<const SnakeEffectConfig*>(
               &_SnakeEffectConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SnakeEffectConfig& a, SnakeEffectConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(SnakeEffectConfig* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SnakeEffectConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SnakeEffectConfig* New() const final {
    return CreateMaybeMessage<SnakeEffectConfig>(nullptr);
  }

  SnakeEffectConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SnakeEffectConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const SnakeEffectConfig& from);
  void MergeFrom(const SnakeEffectConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SnakeEffectConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SnakeEffectConfig";
  }
  protected:
  explicit SnakeEffectConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_effects_2eproto);
    return ::descriptor_table_effects_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeadFieldNumber = 1,
    kTailLengthFieldNumber = 2,
  };
  // .FloatFunction head = 1;
  bool has_head() const;
  private:
  bool _internal_has_head() const;
  public:
  void clear_head();
  const ::FloatFunction& head() const;
  ::FloatFunction* release_head();
  ::FloatFunction* mutable_head();
  void set_allocated_head(::FloatFunction* head);
  private:
  const ::FloatFunction& _internal_head() const;
  ::FloatFunction* _internal_mutable_head();
  public:
  void unsafe_arena_set_allocated_head(
      ::FloatFunction* head);
  ::FloatFunction* unsafe_arena_release_head();

  // .FloatFunction tail_length = 2;
  bool has_tail_length() const;
  private:
  bool _internal_has_tail_length() const;
  public:
  void clear_tail_length();
  const ::FloatFunction& tail_length() const;
  ::FloatFunction* release_tail_length();
  ::FloatFunction* mutable_tail_length();
  void set_allocated_tail_length(::FloatFunction* tail_length);
  private:
  const ::FloatFunction& _internal_tail_length() const;
  ::FloatFunction* _internal_mutable_tail_length();
  public:
  void unsafe_arena_set_allocated_tail_length(
      ::FloatFunction* tail_length);
  ::FloatFunction* unsafe_arena_release_tail_length();

  // @@protoc_insertion_point(class_scope:SnakeEffectConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::FloatFunction* head_;
  ::FloatFunction* tail_length_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_effects_2eproto;
};
// -------------------------------------------------------------------

class AlternateEffectConfig PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AlternateEffectConfig) */ {
 public:
  inline AlternateEffectConfig() : AlternateEffectConfig(nullptr) {}
  virtual ~AlternateEffectConfig();

  AlternateEffectConfig(const AlternateEffectConfig& from);
  AlternateEffectConfig(AlternateEffectConfig&& from) noexcept
    : AlternateEffectConfig() {
    *this = ::std::move(from);
  }

  inline AlternateEffectConfig& operator=(const AlternateEffectConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline AlternateEffectConfig& operator=(AlternateEffectConfig&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AlternateEffectConfig& default_instance();

  static inline const AlternateEffectConfig* internal_default_instance() {
    return reinterpret_cast<const AlternateEffectConfig*>(
               &_AlternateEffectConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(AlternateEffectConfig& a, AlternateEffectConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(AlternateEffectConfig* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AlternateEffectConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AlternateEffectConfig* New() const final {
    return CreateMaybeMessage<AlternateEffectConfig>(nullptr);
  }

  AlternateEffectConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AlternateEffectConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AlternateEffectConfig& from);
  void MergeFrom(const AlternateEffectConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AlternateEffectConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AlternateEffectConfig";
  }
  protected:
  explicit AlternateEffectConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_effects_2eproto);
    return ::descriptor_table_effects_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHueOffsetFieldNumber = 2,
    kSatMultFieldNumber = 3,
    kBrightnessMultFieldNumber = 4,
    kNumberOfPixelsFieldNumber = 1,
  };
  // .FloatFunction hue_offset = 2;
  bool has_hue_offset() const;
  private:
  bool _internal_has_hue_offset() const;
  public:
  void clear_hue_offset();
  const ::FloatFunction& hue_offset() const;
  ::FloatFunction* release_hue_offset();
  ::FloatFunction* mutable_hue_offset();
  void set_allocated_hue_offset(::FloatFunction* hue_offset);
  private:
  const ::FloatFunction& _internal_hue_offset() const;
  ::FloatFunction* _internal_mutable_hue_offset();
  public:
  void unsafe_arena_set_allocated_hue_offset(
      ::FloatFunction* hue_offset);
  ::FloatFunction* unsafe_arena_release_hue_offset();

  // .FloatFunction sat_mult = 3;
  bool has_sat_mult() const;
  private:
  bool _internal_has_sat_mult() const;
  public:
  void clear_sat_mult();
  const ::FloatFunction& sat_mult() const;
  ::FloatFunction* release_sat_mult();
  ::FloatFunction* mutable_sat_mult();
  void set_allocated_sat_mult(::FloatFunction* sat_mult);
  private:
  const ::FloatFunction& _internal_sat_mult() const;
  ::FloatFunction* _internal_mutable_sat_mult();
  public:
  void unsafe_arena_set_allocated_sat_mult(
      ::FloatFunction* sat_mult);
  ::FloatFunction* unsafe_arena_release_sat_mult();

  // .FloatFunction brightness_mult = 4;
  bool has_brightness_mult() const;
  private:
  bool _internal_has_brightness_mult() const;
  public:
  void clear_brightness_mult();
  const ::FloatFunction& brightness_mult() const;
  ::FloatFunction* release_brightness_mult();
  ::FloatFunction* mutable_brightness_mult();
  void set_allocated_brightness_mult(::FloatFunction* brightness_mult);
  private:
  const ::FloatFunction& _internal_brightness_mult() const;
  ::FloatFunction* _internal_mutable_brightness_mult();
  public:
  void unsafe_arena_set_allocated_brightness_mult(
      ::FloatFunction* brightness_mult);
  ::FloatFunction* unsafe_arena_release_brightness_mult();

  // uint32 numberOfPixels = 1;
  void clear_numberofpixels();
  ::PROTOBUF_NAMESPACE_ID::uint32 numberofpixels() const;
  void set_numberofpixels(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_numberofpixels() const;
  void _internal_set_numberofpixels(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:AlternateEffectConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::FloatFunction* hue_offset_;
  ::FloatFunction* sat_mult_;
  ::FloatFunction* brightness_mult_;
  ::PROTOBUF_NAMESPACE_ID::uint32 numberofpixels_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_effects_2eproto;
};
// -------------------------------------------------------------------

class EffectConfig PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:EffectConfig) */ {
 public:
  inline EffectConfig() : EffectConfig(nullptr) {}
  virtual ~EffectConfig();

  EffectConfig(const EffectConfig& from);
  EffectConfig(EffectConfig&& from) noexcept
    : EffectConfig() {
    *this = ::std::move(from);
  }

  inline EffectConfig& operator=(const EffectConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline EffectConfig& operator=(EffectConfig&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EffectConfig& default_instance();

  static inline const EffectConfig* internal_default_instance() {
    return reinterpret_cast<const EffectConfig*>(
               &_EffectConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(EffectConfig& a, EffectConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(EffectConfig* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EffectConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EffectConfig* New() const final {
    return CreateMaybeMessage<EffectConfig>(nullptr);
  }

  EffectConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EffectConfig>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EffectConfig& from);
  void MergeFrom(const EffectConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EffectConfig* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "EffectConfig";
  }
  protected:
  explicit EffectConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_effects_2eproto);
    return ::descriptor_table_effects_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSegmentsFieldNumber = 3,
    kStartTimeFieldNumber = 1,
    kEndTimeFieldNumber = 2,
    kRepeatNumFieldNumber = 4,
    kRepeatStartFieldNumber = 5,
    kRepeatEndFieldNumber = 6,
  };
  // string segments = 3;
  void clear_segments();
  const std::string& segments() const;
  void set_segments(const std::string& value);
  void set_segments(std::string&& value);
  void set_segments(const char* value);
  void set_segments(const char* value, size_t size);
  std::string* mutable_segments();
  std::string* release_segments();
  void set_allocated_segments(std::string* segments);
  private:
  const std::string& _internal_segments() const;
  void _internal_set_segments(const std::string& value);
  std::string* _internal_mutable_segments();
  public:

  // uint32 start_time = 1;
  void clear_start_time();
  ::PROTOBUF_NAMESPACE_ID::uint32 start_time() const;
  void set_start_time(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_start_time() const;
  void _internal_set_start_time(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 end_time = 2;
  void clear_end_time();
  ::PROTOBUF_NAMESPACE_ID::uint32 end_time() const;
  void set_end_time(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_end_time() const;
  void _internal_set_end_time(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // float repeat_num = 4;
  void clear_repeat_num();
  float repeat_num() const;
  void set_repeat_num(float value);
  private:
  float _internal_repeat_num() const;
  void _internal_set_repeat_num(float value);
  public:

  // float repeat_start = 5;
  void clear_repeat_start();
  float repeat_start() const;
  void set_repeat_start(float value);
  private:
  float _internal_repeat_start() const;
  void _internal_set_repeat_start(float value);
  public:

  // float repeat_end = 6;
  void clear_repeat_end();
  float repeat_end() const;
  void set_repeat_end(float value);
  private:
  float _internal_repeat_end() const;
  void _internal_set_repeat_end(float value);
  public:

  // @@protoc_insertion_point(class_scope:EffectConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr segments_;
  ::PROTOBUF_NAMESPACE_ID::uint32 start_time_;
  ::PROTOBUF_NAMESPACE_ID::uint32 end_time_;
  float repeat_num_;
  float repeat_start_;
  float repeat_end_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_effects_2eproto;
};
// -------------------------------------------------------------------

class EffectProto PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:EffectProto) */ {
 public:
  inline EffectProto() : EffectProto(nullptr) {}
  virtual ~EffectProto();

  EffectProto(const EffectProto& from);
  EffectProto(EffectProto&& from) noexcept
    : EffectProto() {
    *this = ::std::move(from);
  }

  inline EffectProto& operator=(const EffectProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline EffectProto& operator=(EffectProto&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const EffectProto& default_instance();

  enum EffectCase {
    kConstColor = 2,
    kRainbow = 3,
    kBrightness = 4,
    kHue = 5,
    kSaturation = 6,
    EFFECT_NOT_SET = 0,
  };

  static inline const EffectProto* internal_default_instance() {
    return reinterpret_cast<const EffectProto*>(
               &_EffectProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(EffectProto& a, EffectProto& b) {
    a.Swap(&b);
  }
  inline void Swap(EffectProto* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EffectProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EffectProto* New() const final {
    return CreateMaybeMessage<EffectProto>(nullptr);
  }

  EffectProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EffectProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const EffectProto& from);
  void MergeFrom(const EffectProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EffectProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "EffectProto";
  }
  protected:
  explicit EffectProto(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_effects_2eproto);
    return ::descriptor_table_effects_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEffectConfigFieldNumber = 1,
    kConstColorFieldNumber = 2,
    kRainbowFieldNumber = 3,
    kBrightnessFieldNumber = 4,
    kHueFieldNumber = 5,
    kSaturationFieldNumber = 6,
  };
  // .EffectConfig effect_config = 1;
  bool has_effect_config() const;
  private:
  bool _internal_has_effect_config() const;
  public:
  void clear_effect_config();
  const ::EffectConfig& effect_config() const;
  ::EffectConfig* release_effect_config();
  ::EffectConfig* mutable_effect_config();
  void set_allocated_effect_config(::EffectConfig* effect_config);
  private:
  const ::EffectConfig& _internal_effect_config() const;
  ::EffectConfig* _internal_mutable_effect_config();
  public:
  void unsafe_arena_set_allocated_effect_config(
      ::EffectConfig* effect_config);
  ::EffectConfig* unsafe_arena_release_effect_config();

  // .ConstColorEffectConfig const_color = 2;
  bool has_const_color() const;
  private:
  bool _internal_has_const_color() const;
  public:
  void clear_const_color();
  const ::ConstColorEffectConfig& const_color() const;
  ::ConstColorEffectConfig* release_const_color();
  ::ConstColorEffectConfig* mutable_const_color();
  void set_allocated_const_color(::ConstColorEffectConfig* const_color);
  private:
  const ::ConstColorEffectConfig& _internal_const_color() const;
  ::ConstColorEffectConfig* _internal_mutable_const_color();
  public:
  void unsafe_arena_set_allocated_const_color(
      ::ConstColorEffectConfig* const_color);
  ::ConstColorEffectConfig* unsafe_arena_release_const_color();

  // .RainbowEffectConfig rainbow = 3;
  bool has_rainbow() const;
  private:
  bool _internal_has_rainbow() const;
  public:
  void clear_rainbow();
  const ::RainbowEffectConfig& rainbow() const;
  ::RainbowEffectConfig* release_rainbow();
  ::RainbowEffectConfig* mutable_rainbow();
  void set_allocated_rainbow(::RainbowEffectConfig* rainbow);
  private:
  const ::RainbowEffectConfig& _internal_rainbow() const;
  ::RainbowEffectConfig* _internal_mutable_rainbow();
  public:
  void unsafe_arena_set_allocated_rainbow(
      ::RainbowEffectConfig* rainbow);
  ::RainbowEffectConfig* unsafe_arena_release_rainbow();

  // .BrightnessEffectConfig brightness = 4;
  bool has_brightness() const;
  private:
  bool _internal_has_brightness() const;
  public:
  void clear_brightness();
  const ::BrightnessEffectConfig& brightness() const;
  ::BrightnessEffectConfig* release_brightness();
  ::BrightnessEffectConfig* mutable_brightness();
  void set_allocated_brightness(::BrightnessEffectConfig* brightness);
  private:
  const ::BrightnessEffectConfig& _internal_brightness() const;
  ::BrightnessEffectConfig* _internal_mutable_brightness();
  public:
  void unsafe_arena_set_allocated_brightness(
      ::BrightnessEffectConfig* brightness);
  ::BrightnessEffectConfig* unsafe_arena_release_brightness();

  // .HueEffectConfig hue = 5;
  bool has_hue() const;
  private:
  bool _internal_has_hue() const;
  public:
  void clear_hue();
  const ::HueEffectConfig& hue() const;
  ::HueEffectConfig* release_hue();
  ::HueEffectConfig* mutable_hue();
  void set_allocated_hue(::HueEffectConfig* hue);
  private:
  const ::HueEffectConfig& _internal_hue() const;
  ::HueEffectConfig* _internal_mutable_hue();
  public:
  void unsafe_arena_set_allocated_hue(
      ::HueEffectConfig* hue);
  ::HueEffectConfig* unsafe_arena_release_hue();

  // .SaturationEffectConfig saturation = 6;
  bool has_saturation() const;
  private:
  bool _internal_has_saturation() const;
  public:
  void clear_saturation();
  const ::SaturationEffectConfig& saturation() const;
  ::SaturationEffectConfig* release_saturation();
  ::SaturationEffectConfig* mutable_saturation();
  void set_allocated_saturation(::SaturationEffectConfig* saturation);
  private:
  const ::SaturationEffectConfig& _internal_saturation() const;
  ::SaturationEffectConfig* _internal_mutable_saturation();
  public:
  void unsafe_arena_set_allocated_saturation(
      ::SaturationEffectConfig* saturation);
  ::SaturationEffectConfig* unsafe_arena_release_saturation();

  void clear_effect();
  EffectCase effect_case() const;
  // @@protoc_insertion_point(class_scope:EffectProto)
 private:
  class _Internal;
  void set_has_const_color();
  void set_has_rainbow();
  void set_has_brightness();
  void set_has_hue();
  void set_has_saturation();

  inline bool has_effect() const;
  inline void clear_has_effect();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::EffectConfig* effect_config_;
  union EffectUnion {
    EffectUnion() {}
    ::ConstColorEffectConfig* const_color_;
    ::RainbowEffectConfig* rainbow_;
    ::BrightnessEffectConfig* brightness_;
    ::HueEffectConfig* hue_;
    ::SaturationEffectConfig* saturation_;
  } effect_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_effects_2eproto;
};
// -------------------------------------------------------------------

class AnimationProto PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AnimationProto) */ {
 public:
  inline AnimationProto() : AnimationProto(nullptr) {}
  virtual ~AnimationProto();

  AnimationProto(const AnimationProto& from);
  AnimationProto(AnimationProto&& from) noexcept
    : AnimationProto() {
    *this = ::std::move(from);
  }

  inline AnimationProto& operator=(const AnimationProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline AnimationProto& operator=(AnimationProto&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AnimationProto& default_instance();

  static inline const AnimationProto* internal_default_instance() {
    return reinterpret_cast<const AnimationProto*>(
               &_AnimationProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(AnimationProto& a, AnimationProto& b) {
    a.Swap(&b);
  }
  inline void Swap(AnimationProto* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AnimationProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AnimationProto* New() const final {
    return CreateMaybeMessage<AnimationProto>(nullptr);
  }

  AnimationProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AnimationProto>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AnimationProto& from);
  void MergeFrom(const AnimationProto& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AnimationProto* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AnimationProto";
  }
  protected:
  explicit AnimationProto(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_effects_2eproto);
    return ::descriptor_table_effects_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEffectsFieldNumber = 1,
    kDurationMsFieldNumber = 2,
    kNumRepeatsFieldNumber = 3,
  };
  // repeated .EffectProto effects = 1;
  int effects_size() const;
  private:
  int _internal_effects_size() const;
  public:
  void clear_effects();
  ::EffectProto* mutable_effects(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::EffectProto >*
      mutable_effects();
  private:
  const ::EffectProto& _internal_effects(int index) const;
  ::EffectProto* _internal_add_effects();
  public:
  const ::EffectProto& effects(int index) const;
  ::EffectProto* add_effects();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::EffectProto >&
      effects() const;

  // uint32 duration_ms = 2;
  void clear_duration_ms();
  ::PROTOBUF_NAMESPACE_ID::uint32 duration_ms() const;
  void set_duration_ms(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_duration_ms() const;
  void _internal_set_duration_ms(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 num_repeats = 3;
  void clear_num_repeats();
  ::PROTOBUF_NAMESPACE_ID::uint32 num_repeats() const;
  void set_num_repeats(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_num_repeats() const;
  void _internal_set_num_repeats(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:AnimationProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::EffectProto > effects_;
  ::PROTOBUF_NAMESPACE_ID::uint32 duration_ms_;
  ::PROTOBUF_NAMESPACE_ID::uint32 num_repeats_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_effects_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// HSV

// float hue = 1;
inline void HSV::clear_hue() {
  hue_ = 0;
}
inline float HSV::_internal_hue() const {
  return hue_;
}
inline float HSV::hue() const {
  // @@protoc_insertion_point(field_get:HSV.hue)
  return _internal_hue();
}
inline void HSV::_internal_set_hue(float value) {
  
  hue_ = value;
}
inline void HSV::set_hue(float value) {
  _internal_set_hue(value);
  // @@protoc_insertion_point(field_set:HSV.hue)
}

// float sat = 2;
inline void HSV::clear_sat() {
  sat_ = 0;
}
inline float HSV::_internal_sat() const {
  return sat_;
}
inline float HSV::sat() const {
  // @@protoc_insertion_point(field_get:HSV.sat)
  return _internal_sat();
}
inline void HSV::_internal_set_sat(float value) {
  
  sat_ = value;
}
inline void HSV::set_sat(float value) {
  _internal_set_sat(value);
  // @@protoc_insertion_point(field_set:HSV.sat)
}

// float val = 3;
inline void HSV::clear_val() {
  val_ = 0;
}
inline float HSV::_internal_val() const {
  return val_;
}
inline float HSV::val() const {
  // @@protoc_insertion_point(field_get:HSV.val)
  return _internal_val();
}
inline void HSV::_internal_set_val(float value) {
  
  val_ = value;
}
inline void HSV::set_val(float value) {
  _internal_set_val(value);
  // @@protoc_insertion_point(field_set:HSV.val)
}

// -------------------------------------------------------------------

// ConstColorEffectConfig

// .HSV color = 1;
inline bool ConstColorEffectConfig::_internal_has_color() const {
  return this != internal_default_instance() && color_ != nullptr;
}
inline bool ConstColorEffectConfig::has_color() const {
  return _internal_has_color();
}
inline void ConstColorEffectConfig::clear_color() {
  if (GetArena() == nullptr && color_ != nullptr) {
    delete color_;
  }
  color_ = nullptr;
}
inline const ::HSV& ConstColorEffectConfig::_internal_color() const {
  const ::HSV* p = color_;
  return p != nullptr ? *p : reinterpret_cast<const ::HSV&>(
      ::_HSV_default_instance_);
}
inline const ::HSV& ConstColorEffectConfig::color() const {
  // @@protoc_insertion_point(field_get:ConstColorEffectConfig.color)
  return _internal_color();
}
inline void ConstColorEffectConfig::unsafe_arena_set_allocated_color(
    ::HSV* color) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(color_);
  }
  color_ = color;
  if (color) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ConstColorEffectConfig.color)
}
inline ::HSV* ConstColorEffectConfig::release_color() {
  
  ::HSV* temp = color_;
  color_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::HSV* ConstColorEffectConfig::unsafe_arena_release_color() {
  // @@protoc_insertion_point(field_release:ConstColorEffectConfig.color)
  
  ::HSV* temp = color_;
  color_ = nullptr;
  return temp;
}
inline ::HSV* ConstColorEffectConfig::_internal_mutable_color() {
  
  if (color_ == nullptr) {
    auto* p = CreateMaybeMessage<::HSV>(GetArena());
    color_ = p;
  }
  return color_;
}
inline ::HSV* ConstColorEffectConfig::mutable_color() {
  // @@protoc_insertion_point(field_mutable:ConstColorEffectConfig.color)
  return _internal_mutable_color();
}
inline void ConstColorEffectConfig::set_allocated_color(::HSV* color) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete color_;
  }
  if (color) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(color);
    if (message_arena != submessage_arena) {
      color = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, color, submessage_arena);
    }
    
  } else {
    
  }
  color_ = color;
  // @@protoc_insertion_point(field_set_allocated:ConstColorEffectConfig.color)
}

// -------------------------------------------------------------------

// RainbowEffectConfig

// .FloatFunction hue_start = 1;
inline bool RainbowEffectConfig::_internal_has_hue_start() const {
  return this != internal_default_instance() && hue_start_ != nullptr;
}
inline bool RainbowEffectConfig::has_hue_start() const {
  return _internal_has_hue_start();
}
inline const ::FloatFunction& RainbowEffectConfig::_internal_hue_start() const {
  const ::FloatFunction* p = hue_start_;
  return p != nullptr ? *p : reinterpret_cast<const ::FloatFunction&>(
      ::_FloatFunction_default_instance_);
}
inline const ::FloatFunction& RainbowEffectConfig::hue_start() const {
  // @@protoc_insertion_point(field_get:RainbowEffectConfig.hue_start)
  return _internal_hue_start();
}
inline void RainbowEffectConfig::unsafe_arena_set_allocated_hue_start(
    ::FloatFunction* hue_start) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hue_start_);
  }
  hue_start_ = hue_start;
  if (hue_start) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RainbowEffectConfig.hue_start)
}
inline ::FloatFunction* RainbowEffectConfig::release_hue_start() {
  
  ::FloatFunction* temp = hue_start_;
  hue_start_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::FloatFunction* RainbowEffectConfig::unsafe_arena_release_hue_start() {
  // @@protoc_insertion_point(field_release:RainbowEffectConfig.hue_start)
  
  ::FloatFunction* temp = hue_start_;
  hue_start_ = nullptr;
  return temp;
}
inline ::FloatFunction* RainbowEffectConfig::_internal_mutable_hue_start() {
  
  if (hue_start_ == nullptr) {
    auto* p = CreateMaybeMessage<::FloatFunction>(GetArena());
    hue_start_ = p;
  }
  return hue_start_;
}
inline ::FloatFunction* RainbowEffectConfig::mutable_hue_start() {
  // @@protoc_insertion_point(field_mutable:RainbowEffectConfig.hue_start)
  return _internal_mutable_hue_start();
}
inline void RainbowEffectConfig::set_allocated_hue_start(::FloatFunction* hue_start) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(hue_start_);
  }
  if (hue_start) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hue_start)->GetArena();
    if (message_arena != submessage_arena) {
      hue_start = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hue_start, submessage_arena);
    }
    
  } else {
    
  }
  hue_start_ = hue_start;
  // @@protoc_insertion_point(field_set_allocated:RainbowEffectConfig.hue_start)
}

// .FloatFunction hue_end = 2;
inline bool RainbowEffectConfig::_internal_has_hue_end() const {
  return this != internal_default_instance() && hue_end_ != nullptr;
}
inline bool RainbowEffectConfig::has_hue_end() const {
  return _internal_has_hue_end();
}
inline const ::FloatFunction& RainbowEffectConfig::_internal_hue_end() const {
  const ::FloatFunction* p = hue_end_;
  return p != nullptr ? *p : reinterpret_cast<const ::FloatFunction&>(
      ::_FloatFunction_default_instance_);
}
inline const ::FloatFunction& RainbowEffectConfig::hue_end() const {
  // @@protoc_insertion_point(field_get:RainbowEffectConfig.hue_end)
  return _internal_hue_end();
}
inline void RainbowEffectConfig::unsafe_arena_set_allocated_hue_end(
    ::FloatFunction* hue_end) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hue_end_);
  }
  hue_end_ = hue_end;
  if (hue_end) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:RainbowEffectConfig.hue_end)
}
inline ::FloatFunction* RainbowEffectConfig::release_hue_end() {
  
  ::FloatFunction* temp = hue_end_;
  hue_end_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::FloatFunction* RainbowEffectConfig::unsafe_arena_release_hue_end() {
  // @@protoc_insertion_point(field_release:RainbowEffectConfig.hue_end)
  
  ::FloatFunction* temp = hue_end_;
  hue_end_ = nullptr;
  return temp;
}
inline ::FloatFunction* RainbowEffectConfig::_internal_mutable_hue_end() {
  
  if (hue_end_ == nullptr) {
    auto* p = CreateMaybeMessage<::FloatFunction>(GetArena());
    hue_end_ = p;
  }
  return hue_end_;
}
inline ::FloatFunction* RainbowEffectConfig::mutable_hue_end() {
  // @@protoc_insertion_point(field_mutable:RainbowEffectConfig.hue_end)
  return _internal_mutable_hue_end();
}
inline void RainbowEffectConfig::set_allocated_hue_end(::FloatFunction* hue_end) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(hue_end_);
  }
  if (hue_end) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hue_end)->GetArena();
    if (message_arena != submessage_arena) {
      hue_end = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hue_end, submessage_arena);
    }
    
  } else {
    
  }
  hue_end_ = hue_end;
  // @@protoc_insertion_point(field_set_allocated:RainbowEffectConfig.hue_end)
}

// -------------------------------------------------------------------

// BrightnessEffectConfig

// .FloatFunction mult_factor = 1;
inline bool BrightnessEffectConfig::_internal_has_mult_factor() const {
  return this != internal_default_instance() && mult_factor_ != nullptr;
}
inline bool BrightnessEffectConfig::has_mult_factor() const {
  return _internal_has_mult_factor();
}
inline const ::FloatFunction& BrightnessEffectConfig::_internal_mult_factor() const {
  const ::FloatFunction* p = mult_factor_;
  return p != nullptr ? *p : reinterpret_cast<const ::FloatFunction&>(
      ::_FloatFunction_default_instance_);
}
inline const ::FloatFunction& BrightnessEffectConfig::mult_factor() const {
  // @@protoc_insertion_point(field_get:BrightnessEffectConfig.mult_factor)
  return _internal_mult_factor();
}
inline void BrightnessEffectConfig::unsafe_arena_set_allocated_mult_factor(
    ::FloatFunction* mult_factor) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mult_factor_);
  }
  mult_factor_ = mult_factor;
  if (mult_factor) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:BrightnessEffectConfig.mult_factor)
}
inline ::FloatFunction* BrightnessEffectConfig::release_mult_factor() {
  
  ::FloatFunction* temp = mult_factor_;
  mult_factor_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::FloatFunction* BrightnessEffectConfig::unsafe_arena_release_mult_factor() {
  // @@protoc_insertion_point(field_release:BrightnessEffectConfig.mult_factor)
  
  ::FloatFunction* temp = mult_factor_;
  mult_factor_ = nullptr;
  return temp;
}
inline ::FloatFunction* BrightnessEffectConfig::_internal_mutable_mult_factor() {
  
  if (mult_factor_ == nullptr) {
    auto* p = CreateMaybeMessage<::FloatFunction>(GetArena());
    mult_factor_ = p;
  }
  return mult_factor_;
}
inline ::FloatFunction* BrightnessEffectConfig::mutable_mult_factor() {
  // @@protoc_insertion_point(field_mutable:BrightnessEffectConfig.mult_factor)
  return _internal_mutable_mult_factor();
}
inline void BrightnessEffectConfig::set_allocated_mult_factor(::FloatFunction* mult_factor) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(mult_factor_);
  }
  if (mult_factor) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mult_factor)->GetArena();
    if (message_arena != submessage_arena) {
      mult_factor = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mult_factor, submessage_arena);
    }
    
  } else {
    
  }
  mult_factor_ = mult_factor;
  // @@protoc_insertion_point(field_set_allocated:BrightnessEffectConfig.mult_factor)
}

// -------------------------------------------------------------------

// HueEffectConfig

// .FloatFunction offset_factor = 1;
inline bool HueEffectConfig::_internal_has_offset_factor() const {
  return this != internal_default_instance() && offset_factor_ != nullptr;
}
inline bool HueEffectConfig::has_offset_factor() const {
  return _internal_has_offset_factor();
}
inline const ::FloatFunction& HueEffectConfig::_internal_offset_factor() const {
  const ::FloatFunction* p = offset_factor_;
  return p != nullptr ? *p : reinterpret_cast<const ::FloatFunction&>(
      ::_FloatFunction_default_instance_);
}
inline const ::FloatFunction& HueEffectConfig::offset_factor() const {
  // @@protoc_insertion_point(field_get:HueEffectConfig.offset_factor)
  return _internal_offset_factor();
}
inline void HueEffectConfig::unsafe_arena_set_allocated_offset_factor(
    ::FloatFunction* offset_factor) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(offset_factor_);
  }
  offset_factor_ = offset_factor;
  if (offset_factor) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:HueEffectConfig.offset_factor)
}
inline ::FloatFunction* HueEffectConfig::release_offset_factor() {
  
  ::FloatFunction* temp = offset_factor_;
  offset_factor_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::FloatFunction* HueEffectConfig::unsafe_arena_release_offset_factor() {
  // @@protoc_insertion_point(field_release:HueEffectConfig.offset_factor)
  
  ::FloatFunction* temp = offset_factor_;
  offset_factor_ = nullptr;
  return temp;
}
inline ::FloatFunction* HueEffectConfig::_internal_mutable_offset_factor() {
  
  if (offset_factor_ == nullptr) {
    auto* p = CreateMaybeMessage<::FloatFunction>(GetArena());
    offset_factor_ = p;
  }
  return offset_factor_;
}
inline ::FloatFunction* HueEffectConfig::mutable_offset_factor() {
  // @@protoc_insertion_point(field_mutable:HueEffectConfig.offset_factor)
  return _internal_mutable_offset_factor();
}
inline void HueEffectConfig::set_allocated_offset_factor(::FloatFunction* offset_factor) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(offset_factor_);
  }
  if (offset_factor) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(offset_factor)->GetArena();
    if (message_arena != submessage_arena) {
      offset_factor = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, offset_factor, submessage_arena);
    }
    
  } else {
    
  }
  offset_factor_ = offset_factor;
  // @@protoc_insertion_point(field_set_allocated:HueEffectConfig.offset_factor)
}

// -------------------------------------------------------------------

// SaturationEffectConfig

// .FloatFunction mult_factor = 1;
inline bool SaturationEffectConfig::_internal_has_mult_factor() const {
  return this != internal_default_instance() && mult_factor_ != nullptr;
}
inline bool SaturationEffectConfig::has_mult_factor() const {
  return _internal_has_mult_factor();
}
inline const ::FloatFunction& SaturationEffectConfig::_internal_mult_factor() const {
  const ::FloatFunction* p = mult_factor_;
  return p != nullptr ? *p : reinterpret_cast<const ::FloatFunction&>(
      ::_FloatFunction_default_instance_);
}
inline const ::FloatFunction& SaturationEffectConfig::mult_factor() const {
  // @@protoc_insertion_point(field_get:SaturationEffectConfig.mult_factor)
  return _internal_mult_factor();
}
inline void SaturationEffectConfig::unsafe_arena_set_allocated_mult_factor(
    ::FloatFunction* mult_factor) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mult_factor_);
  }
  mult_factor_ = mult_factor;
  if (mult_factor) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SaturationEffectConfig.mult_factor)
}
inline ::FloatFunction* SaturationEffectConfig::release_mult_factor() {
  
  ::FloatFunction* temp = mult_factor_;
  mult_factor_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::FloatFunction* SaturationEffectConfig::unsafe_arena_release_mult_factor() {
  // @@protoc_insertion_point(field_release:SaturationEffectConfig.mult_factor)
  
  ::FloatFunction* temp = mult_factor_;
  mult_factor_ = nullptr;
  return temp;
}
inline ::FloatFunction* SaturationEffectConfig::_internal_mutable_mult_factor() {
  
  if (mult_factor_ == nullptr) {
    auto* p = CreateMaybeMessage<::FloatFunction>(GetArena());
    mult_factor_ = p;
  }
  return mult_factor_;
}
inline ::FloatFunction* SaturationEffectConfig::mutable_mult_factor() {
  // @@protoc_insertion_point(field_mutable:SaturationEffectConfig.mult_factor)
  return _internal_mutable_mult_factor();
}
inline void SaturationEffectConfig::set_allocated_mult_factor(::FloatFunction* mult_factor) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(mult_factor_);
  }
  if (mult_factor) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mult_factor)->GetArena();
    if (message_arena != submessage_arena) {
      mult_factor = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mult_factor, submessage_arena);
    }
    
  } else {
    
  }
  mult_factor_ = mult_factor;
  // @@protoc_insertion_point(field_set_allocated:SaturationEffectConfig.mult_factor)
}

// -------------------------------------------------------------------

// SegmentEffectConfig

// .FloatFunction start = 1;
inline bool SegmentEffectConfig::_internal_has_start() const {
  return this != internal_default_instance() && start_ != nullptr;
}
inline bool SegmentEffectConfig::has_start() const {
  return _internal_has_start();
}
inline const ::FloatFunction& SegmentEffectConfig::_internal_start() const {
  const ::FloatFunction* p = start_;
  return p != nullptr ? *p : reinterpret_cast<const ::FloatFunction&>(
      ::_FloatFunction_default_instance_);
}
inline const ::FloatFunction& SegmentEffectConfig::start() const {
  // @@protoc_insertion_point(field_get:SegmentEffectConfig.start)
  return _internal_start();
}
inline void SegmentEffectConfig::unsafe_arena_set_allocated_start(
    ::FloatFunction* start) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_);
  }
  start_ = start;
  if (start) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SegmentEffectConfig.start)
}
inline ::FloatFunction* SegmentEffectConfig::release_start() {
  
  ::FloatFunction* temp = start_;
  start_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::FloatFunction* SegmentEffectConfig::unsafe_arena_release_start() {
  // @@protoc_insertion_point(field_release:SegmentEffectConfig.start)
  
  ::FloatFunction* temp = start_;
  start_ = nullptr;
  return temp;
}
inline ::FloatFunction* SegmentEffectConfig::_internal_mutable_start() {
  
  if (start_ == nullptr) {
    auto* p = CreateMaybeMessage<::FloatFunction>(GetArena());
    start_ = p;
  }
  return start_;
}
inline ::FloatFunction* SegmentEffectConfig::mutable_start() {
  // @@protoc_insertion_point(field_mutable:SegmentEffectConfig.start)
  return _internal_mutable_start();
}
inline void SegmentEffectConfig::set_allocated_start(::FloatFunction* start) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(start_);
  }
  if (start) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(start)->GetArena();
    if (message_arena != submessage_arena) {
      start = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start, submessage_arena);
    }
    
  } else {
    
  }
  start_ = start;
  // @@protoc_insertion_point(field_set_allocated:SegmentEffectConfig.start)
}

// .FloatFunction end = 2;
inline bool SegmentEffectConfig::_internal_has_end() const {
  return this != internal_default_instance() && end_ != nullptr;
}
inline bool SegmentEffectConfig::has_end() const {
  return _internal_has_end();
}
inline const ::FloatFunction& SegmentEffectConfig::_internal_end() const {
  const ::FloatFunction* p = end_;
  return p != nullptr ? *p : reinterpret_cast<const ::FloatFunction&>(
      ::_FloatFunction_default_instance_);
}
inline const ::FloatFunction& SegmentEffectConfig::end() const {
  // @@protoc_insertion_point(field_get:SegmentEffectConfig.end)
  return _internal_end();
}
inline void SegmentEffectConfig::unsafe_arena_set_allocated_end(
    ::FloatFunction* end) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_);
  }
  end_ = end;
  if (end) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SegmentEffectConfig.end)
}
inline ::FloatFunction* SegmentEffectConfig::release_end() {
  
  ::FloatFunction* temp = end_;
  end_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::FloatFunction* SegmentEffectConfig::unsafe_arena_release_end() {
  // @@protoc_insertion_point(field_release:SegmentEffectConfig.end)
  
  ::FloatFunction* temp = end_;
  end_ = nullptr;
  return temp;
}
inline ::FloatFunction* SegmentEffectConfig::_internal_mutable_end() {
  
  if (end_ == nullptr) {
    auto* p = CreateMaybeMessage<::FloatFunction>(GetArena());
    end_ = p;
  }
  return end_;
}
inline ::FloatFunction* SegmentEffectConfig::mutable_end() {
  // @@protoc_insertion_point(field_mutable:SegmentEffectConfig.end)
  return _internal_mutable_end();
}
inline void SegmentEffectConfig::set_allocated_end(::FloatFunction* end) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(end_);
  }
  if (end) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(end)->GetArena();
    if (message_arena != submessage_arena) {
      end = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, end, submessage_arena);
    }
    
  } else {
    
  }
  end_ = end;
  // @@protoc_insertion_point(field_set_allocated:SegmentEffectConfig.end)
}

// -------------------------------------------------------------------

// GlitterEffectConfig

// .FloatFunction intensity = 1;
inline bool GlitterEffectConfig::_internal_has_intensity() const {
  return this != internal_default_instance() && intensity_ != nullptr;
}
inline bool GlitterEffectConfig::has_intensity() const {
  return _internal_has_intensity();
}
inline const ::FloatFunction& GlitterEffectConfig::_internal_intensity() const {
  const ::FloatFunction* p = intensity_;
  return p != nullptr ? *p : reinterpret_cast<const ::FloatFunction&>(
      ::_FloatFunction_default_instance_);
}
inline const ::FloatFunction& GlitterEffectConfig::intensity() const {
  // @@protoc_insertion_point(field_get:GlitterEffectConfig.intensity)
  return _internal_intensity();
}
inline void GlitterEffectConfig::unsafe_arena_set_allocated_intensity(
    ::FloatFunction* intensity) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(intensity_);
  }
  intensity_ = intensity;
  if (intensity) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GlitterEffectConfig.intensity)
}
inline ::FloatFunction* GlitterEffectConfig::release_intensity() {
  
  ::FloatFunction* temp = intensity_;
  intensity_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::FloatFunction* GlitterEffectConfig::unsafe_arena_release_intensity() {
  // @@protoc_insertion_point(field_release:GlitterEffectConfig.intensity)
  
  ::FloatFunction* temp = intensity_;
  intensity_ = nullptr;
  return temp;
}
inline ::FloatFunction* GlitterEffectConfig::_internal_mutable_intensity() {
  
  if (intensity_ == nullptr) {
    auto* p = CreateMaybeMessage<::FloatFunction>(GetArena());
    intensity_ = p;
  }
  return intensity_;
}
inline ::FloatFunction* GlitterEffectConfig::mutable_intensity() {
  // @@protoc_insertion_point(field_mutable:GlitterEffectConfig.intensity)
  return _internal_mutable_intensity();
}
inline void GlitterEffectConfig::set_allocated_intensity(::FloatFunction* intensity) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(intensity_);
  }
  if (intensity) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(intensity)->GetArena();
    if (message_arena != submessage_arena) {
      intensity = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, intensity, submessage_arena);
    }
    
  } else {
    
  }
  intensity_ = intensity;
  // @@protoc_insertion_point(field_set_allocated:GlitterEffectConfig.intensity)
}

// .FloatFunction sat_mult_factor = 2;
inline bool GlitterEffectConfig::_internal_has_sat_mult_factor() const {
  return this != internal_default_instance() && sat_mult_factor_ != nullptr;
}
inline bool GlitterEffectConfig::has_sat_mult_factor() const {
  return _internal_has_sat_mult_factor();
}
inline const ::FloatFunction& GlitterEffectConfig::_internal_sat_mult_factor() const {
  const ::FloatFunction* p = sat_mult_factor_;
  return p != nullptr ? *p : reinterpret_cast<const ::FloatFunction&>(
      ::_FloatFunction_default_instance_);
}
inline const ::FloatFunction& GlitterEffectConfig::sat_mult_factor() const {
  // @@protoc_insertion_point(field_get:GlitterEffectConfig.sat_mult_factor)
  return _internal_sat_mult_factor();
}
inline void GlitterEffectConfig::unsafe_arena_set_allocated_sat_mult_factor(
    ::FloatFunction* sat_mult_factor) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sat_mult_factor_);
  }
  sat_mult_factor_ = sat_mult_factor;
  if (sat_mult_factor) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GlitterEffectConfig.sat_mult_factor)
}
inline ::FloatFunction* GlitterEffectConfig::release_sat_mult_factor() {
  
  ::FloatFunction* temp = sat_mult_factor_;
  sat_mult_factor_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::FloatFunction* GlitterEffectConfig::unsafe_arena_release_sat_mult_factor() {
  // @@protoc_insertion_point(field_release:GlitterEffectConfig.sat_mult_factor)
  
  ::FloatFunction* temp = sat_mult_factor_;
  sat_mult_factor_ = nullptr;
  return temp;
}
inline ::FloatFunction* GlitterEffectConfig::_internal_mutable_sat_mult_factor() {
  
  if (sat_mult_factor_ == nullptr) {
    auto* p = CreateMaybeMessage<::FloatFunction>(GetArena());
    sat_mult_factor_ = p;
  }
  return sat_mult_factor_;
}
inline ::FloatFunction* GlitterEffectConfig::mutable_sat_mult_factor() {
  // @@protoc_insertion_point(field_mutable:GlitterEffectConfig.sat_mult_factor)
  return _internal_mutable_sat_mult_factor();
}
inline void GlitterEffectConfig::set_allocated_sat_mult_factor(::FloatFunction* sat_mult_factor) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(sat_mult_factor_);
  }
  if (sat_mult_factor) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sat_mult_factor)->GetArena();
    if (message_arena != submessage_arena) {
      sat_mult_factor = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sat_mult_factor, submessage_arena);
    }
    
  } else {
    
  }
  sat_mult_factor_ = sat_mult_factor;
  // @@protoc_insertion_point(field_set_allocated:GlitterEffectConfig.sat_mult_factor)
}

// -------------------------------------------------------------------

// SnakeEffectConfig

// .FloatFunction head = 1;
inline bool SnakeEffectConfig::_internal_has_head() const {
  return this != internal_default_instance() && head_ != nullptr;
}
inline bool SnakeEffectConfig::has_head() const {
  return _internal_has_head();
}
inline const ::FloatFunction& SnakeEffectConfig::_internal_head() const {
  const ::FloatFunction* p = head_;
  return p != nullptr ? *p : reinterpret_cast<const ::FloatFunction&>(
      ::_FloatFunction_default_instance_);
}
inline const ::FloatFunction& SnakeEffectConfig::head() const {
  // @@protoc_insertion_point(field_get:SnakeEffectConfig.head)
  return _internal_head();
}
inline void SnakeEffectConfig::unsafe_arena_set_allocated_head(
    ::FloatFunction* head) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(head_);
  }
  head_ = head;
  if (head) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SnakeEffectConfig.head)
}
inline ::FloatFunction* SnakeEffectConfig::release_head() {
  
  ::FloatFunction* temp = head_;
  head_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::FloatFunction* SnakeEffectConfig::unsafe_arena_release_head() {
  // @@protoc_insertion_point(field_release:SnakeEffectConfig.head)
  
  ::FloatFunction* temp = head_;
  head_ = nullptr;
  return temp;
}
inline ::FloatFunction* SnakeEffectConfig::_internal_mutable_head() {
  
  if (head_ == nullptr) {
    auto* p = CreateMaybeMessage<::FloatFunction>(GetArena());
    head_ = p;
  }
  return head_;
}
inline ::FloatFunction* SnakeEffectConfig::mutable_head() {
  // @@protoc_insertion_point(field_mutable:SnakeEffectConfig.head)
  return _internal_mutable_head();
}
inline void SnakeEffectConfig::set_allocated_head(::FloatFunction* head) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(head_);
  }
  if (head) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(head)->GetArena();
    if (message_arena != submessage_arena) {
      head = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, head, submessage_arena);
    }
    
  } else {
    
  }
  head_ = head;
  // @@protoc_insertion_point(field_set_allocated:SnakeEffectConfig.head)
}

// .FloatFunction tail_length = 2;
inline bool SnakeEffectConfig::_internal_has_tail_length() const {
  return this != internal_default_instance() && tail_length_ != nullptr;
}
inline bool SnakeEffectConfig::has_tail_length() const {
  return _internal_has_tail_length();
}
inline const ::FloatFunction& SnakeEffectConfig::_internal_tail_length() const {
  const ::FloatFunction* p = tail_length_;
  return p != nullptr ? *p : reinterpret_cast<const ::FloatFunction&>(
      ::_FloatFunction_default_instance_);
}
inline const ::FloatFunction& SnakeEffectConfig::tail_length() const {
  // @@protoc_insertion_point(field_get:SnakeEffectConfig.tail_length)
  return _internal_tail_length();
}
inline void SnakeEffectConfig::unsafe_arena_set_allocated_tail_length(
    ::FloatFunction* tail_length) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tail_length_);
  }
  tail_length_ = tail_length;
  if (tail_length) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:SnakeEffectConfig.tail_length)
}
inline ::FloatFunction* SnakeEffectConfig::release_tail_length() {
  
  ::FloatFunction* temp = tail_length_;
  tail_length_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::FloatFunction* SnakeEffectConfig::unsafe_arena_release_tail_length() {
  // @@protoc_insertion_point(field_release:SnakeEffectConfig.tail_length)
  
  ::FloatFunction* temp = tail_length_;
  tail_length_ = nullptr;
  return temp;
}
inline ::FloatFunction* SnakeEffectConfig::_internal_mutable_tail_length() {
  
  if (tail_length_ == nullptr) {
    auto* p = CreateMaybeMessage<::FloatFunction>(GetArena());
    tail_length_ = p;
  }
  return tail_length_;
}
inline ::FloatFunction* SnakeEffectConfig::mutable_tail_length() {
  // @@protoc_insertion_point(field_mutable:SnakeEffectConfig.tail_length)
  return _internal_mutable_tail_length();
}
inline void SnakeEffectConfig::set_allocated_tail_length(::FloatFunction* tail_length) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(tail_length_);
  }
  if (tail_length) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tail_length)->GetArena();
    if (message_arena != submessage_arena) {
      tail_length = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tail_length, submessage_arena);
    }
    
  } else {
    
  }
  tail_length_ = tail_length;
  // @@protoc_insertion_point(field_set_allocated:SnakeEffectConfig.tail_length)
}

// -------------------------------------------------------------------

// AlternateEffectConfig

// uint32 numberOfPixels = 1;
inline void AlternateEffectConfig::clear_numberofpixels() {
  numberofpixels_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AlternateEffectConfig::_internal_numberofpixels() const {
  return numberofpixels_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AlternateEffectConfig::numberofpixels() const {
  // @@protoc_insertion_point(field_get:AlternateEffectConfig.numberOfPixels)
  return _internal_numberofpixels();
}
inline void AlternateEffectConfig::_internal_set_numberofpixels(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  numberofpixels_ = value;
}
inline void AlternateEffectConfig::set_numberofpixels(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_numberofpixels(value);
  // @@protoc_insertion_point(field_set:AlternateEffectConfig.numberOfPixels)
}

// .FloatFunction hue_offset = 2;
inline bool AlternateEffectConfig::_internal_has_hue_offset() const {
  return this != internal_default_instance() && hue_offset_ != nullptr;
}
inline bool AlternateEffectConfig::has_hue_offset() const {
  return _internal_has_hue_offset();
}
inline const ::FloatFunction& AlternateEffectConfig::_internal_hue_offset() const {
  const ::FloatFunction* p = hue_offset_;
  return p != nullptr ? *p : reinterpret_cast<const ::FloatFunction&>(
      ::_FloatFunction_default_instance_);
}
inline const ::FloatFunction& AlternateEffectConfig::hue_offset() const {
  // @@protoc_insertion_point(field_get:AlternateEffectConfig.hue_offset)
  return _internal_hue_offset();
}
inline void AlternateEffectConfig::unsafe_arena_set_allocated_hue_offset(
    ::FloatFunction* hue_offset) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hue_offset_);
  }
  hue_offset_ = hue_offset;
  if (hue_offset) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:AlternateEffectConfig.hue_offset)
}
inline ::FloatFunction* AlternateEffectConfig::release_hue_offset() {
  
  ::FloatFunction* temp = hue_offset_;
  hue_offset_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::FloatFunction* AlternateEffectConfig::unsafe_arena_release_hue_offset() {
  // @@protoc_insertion_point(field_release:AlternateEffectConfig.hue_offset)
  
  ::FloatFunction* temp = hue_offset_;
  hue_offset_ = nullptr;
  return temp;
}
inline ::FloatFunction* AlternateEffectConfig::_internal_mutable_hue_offset() {
  
  if (hue_offset_ == nullptr) {
    auto* p = CreateMaybeMessage<::FloatFunction>(GetArena());
    hue_offset_ = p;
  }
  return hue_offset_;
}
inline ::FloatFunction* AlternateEffectConfig::mutable_hue_offset() {
  // @@protoc_insertion_point(field_mutable:AlternateEffectConfig.hue_offset)
  return _internal_mutable_hue_offset();
}
inline void AlternateEffectConfig::set_allocated_hue_offset(::FloatFunction* hue_offset) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(hue_offset_);
  }
  if (hue_offset) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hue_offset)->GetArena();
    if (message_arena != submessage_arena) {
      hue_offset = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hue_offset, submessage_arena);
    }
    
  } else {
    
  }
  hue_offset_ = hue_offset;
  // @@protoc_insertion_point(field_set_allocated:AlternateEffectConfig.hue_offset)
}

// .FloatFunction sat_mult = 3;
inline bool AlternateEffectConfig::_internal_has_sat_mult() const {
  return this != internal_default_instance() && sat_mult_ != nullptr;
}
inline bool AlternateEffectConfig::has_sat_mult() const {
  return _internal_has_sat_mult();
}
inline const ::FloatFunction& AlternateEffectConfig::_internal_sat_mult() const {
  const ::FloatFunction* p = sat_mult_;
  return p != nullptr ? *p : reinterpret_cast<const ::FloatFunction&>(
      ::_FloatFunction_default_instance_);
}
inline const ::FloatFunction& AlternateEffectConfig::sat_mult() const {
  // @@protoc_insertion_point(field_get:AlternateEffectConfig.sat_mult)
  return _internal_sat_mult();
}
inline void AlternateEffectConfig::unsafe_arena_set_allocated_sat_mult(
    ::FloatFunction* sat_mult) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sat_mult_);
  }
  sat_mult_ = sat_mult;
  if (sat_mult) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:AlternateEffectConfig.sat_mult)
}
inline ::FloatFunction* AlternateEffectConfig::release_sat_mult() {
  
  ::FloatFunction* temp = sat_mult_;
  sat_mult_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::FloatFunction* AlternateEffectConfig::unsafe_arena_release_sat_mult() {
  // @@protoc_insertion_point(field_release:AlternateEffectConfig.sat_mult)
  
  ::FloatFunction* temp = sat_mult_;
  sat_mult_ = nullptr;
  return temp;
}
inline ::FloatFunction* AlternateEffectConfig::_internal_mutable_sat_mult() {
  
  if (sat_mult_ == nullptr) {
    auto* p = CreateMaybeMessage<::FloatFunction>(GetArena());
    sat_mult_ = p;
  }
  return sat_mult_;
}
inline ::FloatFunction* AlternateEffectConfig::mutable_sat_mult() {
  // @@protoc_insertion_point(field_mutable:AlternateEffectConfig.sat_mult)
  return _internal_mutable_sat_mult();
}
inline void AlternateEffectConfig::set_allocated_sat_mult(::FloatFunction* sat_mult) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(sat_mult_);
  }
  if (sat_mult) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sat_mult)->GetArena();
    if (message_arena != submessage_arena) {
      sat_mult = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sat_mult, submessage_arena);
    }
    
  } else {
    
  }
  sat_mult_ = sat_mult;
  // @@protoc_insertion_point(field_set_allocated:AlternateEffectConfig.sat_mult)
}

// .FloatFunction brightness_mult = 4;
inline bool AlternateEffectConfig::_internal_has_brightness_mult() const {
  return this != internal_default_instance() && brightness_mult_ != nullptr;
}
inline bool AlternateEffectConfig::has_brightness_mult() const {
  return _internal_has_brightness_mult();
}
inline const ::FloatFunction& AlternateEffectConfig::_internal_brightness_mult() const {
  const ::FloatFunction* p = brightness_mult_;
  return p != nullptr ? *p : reinterpret_cast<const ::FloatFunction&>(
      ::_FloatFunction_default_instance_);
}
inline const ::FloatFunction& AlternateEffectConfig::brightness_mult() const {
  // @@protoc_insertion_point(field_get:AlternateEffectConfig.brightness_mult)
  return _internal_brightness_mult();
}
inline void AlternateEffectConfig::unsafe_arena_set_allocated_brightness_mult(
    ::FloatFunction* brightness_mult) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(brightness_mult_);
  }
  brightness_mult_ = brightness_mult;
  if (brightness_mult) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:AlternateEffectConfig.brightness_mult)
}
inline ::FloatFunction* AlternateEffectConfig::release_brightness_mult() {
  
  ::FloatFunction* temp = brightness_mult_;
  brightness_mult_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::FloatFunction* AlternateEffectConfig::unsafe_arena_release_brightness_mult() {
  // @@protoc_insertion_point(field_release:AlternateEffectConfig.brightness_mult)
  
  ::FloatFunction* temp = brightness_mult_;
  brightness_mult_ = nullptr;
  return temp;
}
inline ::FloatFunction* AlternateEffectConfig::_internal_mutable_brightness_mult() {
  
  if (brightness_mult_ == nullptr) {
    auto* p = CreateMaybeMessage<::FloatFunction>(GetArena());
    brightness_mult_ = p;
  }
  return brightness_mult_;
}
inline ::FloatFunction* AlternateEffectConfig::mutable_brightness_mult() {
  // @@protoc_insertion_point(field_mutable:AlternateEffectConfig.brightness_mult)
  return _internal_mutable_brightness_mult();
}
inline void AlternateEffectConfig::set_allocated_brightness_mult(::FloatFunction* brightness_mult) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(brightness_mult_);
  }
  if (brightness_mult) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(brightness_mult)->GetArena();
    if (message_arena != submessage_arena) {
      brightness_mult = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, brightness_mult, submessage_arena);
    }
    
  } else {
    
  }
  brightness_mult_ = brightness_mult;
  // @@protoc_insertion_point(field_set_allocated:AlternateEffectConfig.brightness_mult)
}

// -------------------------------------------------------------------

// EffectConfig

// uint32 start_time = 1;
inline void EffectConfig::clear_start_time() {
  start_time_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 EffectConfig::_internal_start_time() const {
  return start_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 EffectConfig::start_time() const {
  // @@protoc_insertion_point(field_get:EffectConfig.start_time)
  return _internal_start_time();
}
inline void EffectConfig::_internal_set_start_time(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  start_time_ = value;
}
inline void EffectConfig::set_start_time(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_start_time(value);
  // @@protoc_insertion_point(field_set:EffectConfig.start_time)
}

// uint32 end_time = 2;
inline void EffectConfig::clear_end_time() {
  end_time_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 EffectConfig::_internal_end_time() const {
  return end_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 EffectConfig::end_time() const {
  // @@protoc_insertion_point(field_get:EffectConfig.end_time)
  return _internal_end_time();
}
inline void EffectConfig::_internal_set_end_time(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  end_time_ = value;
}
inline void EffectConfig::set_end_time(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_end_time(value);
  // @@protoc_insertion_point(field_set:EffectConfig.end_time)
}

// string segments = 3;
inline void EffectConfig::clear_segments() {
  segments_.ClearToEmpty();
}
inline const std::string& EffectConfig::segments() const {
  // @@protoc_insertion_point(field_get:EffectConfig.segments)
  return _internal_segments();
}
inline void EffectConfig::set_segments(const std::string& value) {
  _internal_set_segments(value);
  // @@protoc_insertion_point(field_set:EffectConfig.segments)
}
inline std::string* EffectConfig::mutable_segments() {
  // @@protoc_insertion_point(field_mutable:EffectConfig.segments)
  return _internal_mutable_segments();
}
inline const std::string& EffectConfig::_internal_segments() const {
  return segments_.Get();
}
inline void EffectConfig::_internal_set_segments(const std::string& value) {
  
  segments_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void EffectConfig::set_segments(std::string&& value) {
  
  segments_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:EffectConfig.segments)
}
inline void EffectConfig::set_segments(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  segments_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:EffectConfig.segments)
}
inline void EffectConfig::set_segments(const char* value,
    size_t size) {
  
  segments_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:EffectConfig.segments)
}
inline std::string* EffectConfig::_internal_mutable_segments() {
  
  return segments_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* EffectConfig::release_segments() {
  // @@protoc_insertion_point(field_release:EffectConfig.segments)
  return segments_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void EffectConfig::set_allocated_segments(std::string* segments) {
  if (segments != nullptr) {
    
  } else {
    
  }
  segments_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), segments,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:EffectConfig.segments)
}

// float repeat_num = 4;
inline void EffectConfig::clear_repeat_num() {
  repeat_num_ = 0;
}
inline float EffectConfig::_internal_repeat_num() const {
  return repeat_num_;
}
inline float EffectConfig::repeat_num() const {
  // @@protoc_insertion_point(field_get:EffectConfig.repeat_num)
  return _internal_repeat_num();
}
inline void EffectConfig::_internal_set_repeat_num(float value) {
  
  repeat_num_ = value;
}
inline void EffectConfig::set_repeat_num(float value) {
  _internal_set_repeat_num(value);
  // @@protoc_insertion_point(field_set:EffectConfig.repeat_num)
}

// float repeat_start = 5;
inline void EffectConfig::clear_repeat_start() {
  repeat_start_ = 0;
}
inline float EffectConfig::_internal_repeat_start() const {
  return repeat_start_;
}
inline float EffectConfig::repeat_start() const {
  // @@protoc_insertion_point(field_get:EffectConfig.repeat_start)
  return _internal_repeat_start();
}
inline void EffectConfig::_internal_set_repeat_start(float value) {
  
  repeat_start_ = value;
}
inline void EffectConfig::set_repeat_start(float value) {
  _internal_set_repeat_start(value);
  // @@protoc_insertion_point(field_set:EffectConfig.repeat_start)
}

// float repeat_end = 6;
inline void EffectConfig::clear_repeat_end() {
  repeat_end_ = 0;
}
inline float EffectConfig::_internal_repeat_end() const {
  return repeat_end_;
}
inline float EffectConfig::repeat_end() const {
  // @@protoc_insertion_point(field_get:EffectConfig.repeat_end)
  return _internal_repeat_end();
}
inline void EffectConfig::_internal_set_repeat_end(float value) {
  
  repeat_end_ = value;
}
inline void EffectConfig::set_repeat_end(float value) {
  _internal_set_repeat_end(value);
  // @@protoc_insertion_point(field_set:EffectConfig.repeat_end)
}

// -------------------------------------------------------------------

// EffectProto

// .EffectConfig effect_config = 1;
inline bool EffectProto::_internal_has_effect_config() const {
  return this != internal_default_instance() && effect_config_ != nullptr;
}
inline bool EffectProto::has_effect_config() const {
  return _internal_has_effect_config();
}
inline void EffectProto::clear_effect_config() {
  if (GetArena() == nullptr && effect_config_ != nullptr) {
    delete effect_config_;
  }
  effect_config_ = nullptr;
}
inline const ::EffectConfig& EffectProto::_internal_effect_config() const {
  const ::EffectConfig* p = effect_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::EffectConfig&>(
      ::_EffectConfig_default_instance_);
}
inline const ::EffectConfig& EffectProto::effect_config() const {
  // @@protoc_insertion_point(field_get:EffectProto.effect_config)
  return _internal_effect_config();
}
inline void EffectProto::unsafe_arena_set_allocated_effect_config(
    ::EffectConfig* effect_config) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(effect_config_);
  }
  effect_config_ = effect_config;
  if (effect_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:EffectProto.effect_config)
}
inline ::EffectConfig* EffectProto::release_effect_config() {
  
  ::EffectConfig* temp = effect_config_;
  effect_config_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::EffectConfig* EffectProto::unsafe_arena_release_effect_config() {
  // @@protoc_insertion_point(field_release:EffectProto.effect_config)
  
  ::EffectConfig* temp = effect_config_;
  effect_config_ = nullptr;
  return temp;
}
inline ::EffectConfig* EffectProto::_internal_mutable_effect_config() {
  
  if (effect_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::EffectConfig>(GetArena());
    effect_config_ = p;
  }
  return effect_config_;
}
inline ::EffectConfig* EffectProto::mutable_effect_config() {
  // @@protoc_insertion_point(field_mutable:EffectProto.effect_config)
  return _internal_mutable_effect_config();
}
inline void EffectProto::set_allocated_effect_config(::EffectConfig* effect_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete effect_config_;
  }
  if (effect_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(effect_config);
    if (message_arena != submessage_arena) {
      effect_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, effect_config, submessage_arena);
    }
    
  } else {
    
  }
  effect_config_ = effect_config;
  // @@protoc_insertion_point(field_set_allocated:EffectProto.effect_config)
}

// .ConstColorEffectConfig const_color = 2;
inline bool EffectProto::_internal_has_const_color() const {
  return effect_case() == kConstColor;
}
inline bool EffectProto::has_const_color() const {
  return _internal_has_const_color();
}
inline void EffectProto::set_has_const_color() {
  _oneof_case_[0] = kConstColor;
}
inline void EffectProto::clear_const_color() {
  if (_internal_has_const_color()) {
    if (GetArena() == nullptr) {
      delete effect_.const_color_;
    }
    clear_has_effect();
  }
}
inline ::ConstColorEffectConfig* EffectProto::release_const_color() {
  // @@protoc_insertion_point(field_release:EffectProto.const_color)
  if (_internal_has_const_color()) {
    clear_has_effect();
      ::ConstColorEffectConfig* temp = effect_.const_color_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    effect_.const_color_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ConstColorEffectConfig& EffectProto::_internal_const_color() const {
  return _internal_has_const_color()
      ? *effect_.const_color_
      : reinterpret_cast< ::ConstColorEffectConfig&>(::_ConstColorEffectConfig_default_instance_);
}
inline const ::ConstColorEffectConfig& EffectProto::const_color() const {
  // @@protoc_insertion_point(field_get:EffectProto.const_color)
  return _internal_const_color();
}
inline ::ConstColorEffectConfig* EffectProto::unsafe_arena_release_const_color() {
  // @@protoc_insertion_point(field_unsafe_arena_release:EffectProto.const_color)
  if (_internal_has_const_color()) {
    clear_has_effect();
    ::ConstColorEffectConfig* temp = effect_.const_color_;
    effect_.const_color_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EffectProto::unsafe_arena_set_allocated_const_color(::ConstColorEffectConfig* const_color) {
  clear_effect();
  if (const_color) {
    set_has_const_color();
    effect_.const_color_ = const_color;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:EffectProto.const_color)
}
inline ::ConstColorEffectConfig* EffectProto::_internal_mutable_const_color() {
  if (!_internal_has_const_color()) {
    clear_effect();
    set_has_const_color();
    effect_.const_color_ = CreateMaybeMessage< ::ConstColorEffectConfig >(GetArena());
  }
  return effect_.const_color_;
}
inline ::ConstColorEffectConfig* EffectProto::mutable_const_color() {
  // @@protoc_insertion_point(field_mutable:EffectProto.const_color)
  return _internal_mutable_const_color();
}

// .RainbowEffectConfig rainbow = 3;
inline bool EffectProto::_internal_has_rainbow() const {
  return effect_case() == kRainbow;
}
inline bool EffectProto::has_rainbow() const {
  return _internal_has_rainbow();
}
inline void EffectProto::set_has_rainbow() {
  _oneof_case_[0] = kRainbow;
}
inline void EffectProto::clear_rainbow() {
  if (_internal_has_rainbow()) {
    if (GetArena() == nullptr) {
      delete effect_.rainbow_;
    }
    clear_has_effect();
  }
}
inline ::RainbowEffectConfig* EffectProto::release_rainbow() {
  // @@protoc_insertion_point(field_release:EffectProto.rainbow)
  if (_internal_has_rainbow()) {
    clear_has_effect();
      ::RainbowEffectConfig* temp = effect_.rainbow_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    effect_.rainbow_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::RainbowEffectConfig& EffectProto::_internal_rainbow() const {
  return _internal_has_rainbow()
      ? *effect_.rainbow_
      : reinterpret_cast< ::RainbowEffectConfig&>(::_RainbowEffectConfig_default_instance_);
}
inline const ::RainbowEffectConfig& EffectProto::rainbow() const {
  // @@protoc_insertion_point(field_get:EffectProto.rainbow)
  return _internal_rainbow();
}
inline ::RainbowEffectConfig* EffectProto::unsafe_arena_release_rainbow() {
  // @@protoc_insertion_point(field_unsafe_arena_release:EffectProto.rainbow)
  if (_internal_has_rainbow()) {
    clear_has_effect();
    ::RainbowEffectConfig* temp = effect_.rainbow_;
    effect_.rainbow_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EffectProto::unsafe_arena_set_allocated_rainbow(::RainbowEffectConfig* rainbow) {
  clear_effect();
  if (rainbow) {
    set_has_rainbow();
    effect_.rainbow_ = rainbow;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:EffectProto.rainbow)
}
inline ::RainbowEffectConfig* EffectProto::_internal_mutable_rainbow() {
  if (!_internal_has_rainbow()) {
    clear_effect();
    set_has_rainbow();
    effect_.rainbow_ = CreateMaybeMessage< ::RainbowEffectConfig >(GetArena());
  }
  return effect_.rainbow_;
}
inline ::RainbowEffectConfig* EffectProto::mutable_rainbow() {
  // @@protoc_insertion_point(field_mutable:EffectProto.rainbow)
  return _internal_mutable_rainbow();
}

// .BrightnessEffectConfig brightness = 4;
inline bool EffectProto::_internal_has_brightness() const {
  return effect_case() == kBrightness;
}
inline bool EffectProto::has_brightness() const {
  return _internal_has_brightness();
}
inline void EffectProto::set_has_brightness() {
  _oneof_case_[0] = kBrightness;
}
inline void EffectProto::clear_brightness() {
  if (_internal_has_brightness()) {
    if (GetArena() == nullptr) {
      delete effect_.brightness_;
    }
    clear_has_effect();
  }
}
inline ::BrightnessEffectConfig* EffectProto::release_brightness() {
  // @@protoc_insertion_point(field_release:EffectProto.brightness)
  if (_internal_has_brightness()) {
    clear_has_effect();
      ::BrightnessEffectConfig* temp = effect_.brightness_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    effect_.brightness_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::BrightnessEffectConfig& EffectProto::_internal_brightness() const {
  return _internal_has_brightness()
      ? *effect_.brightness_
      : reinterpret_cast< ::BrightnessEffectConfig&>(::_BrightnessEffectConfig_default_instance_);
}
inline const ::BrightnessEffectConfig& EffectProto::brightness() const {
  // @@protoc_insertion_point(field_get:EffectProto.brightness)
  return _internal_brightness();
}
inline ::BrightnessEffectConfig* EffectProto::unsafe_arena_release_brightness() {
  // @@protoc_insertion_point(field_unsafe_arena_release:EffectProto.brightness)
  if (_internal_has_brightness()) {
    clear_has_effect();
    ::BrightnessEffectConfig* temp = effect_.brightness_;
    effect_.brightness_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EffectProto::unsafe_arena_set_allocated_brightness(::BrightnessEffectConfig* brightness) {
  clear_effect();
  if (brightness) {
    set_has_brightness();
    effect_.brightness_ = brightness;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:EffectProto.brightness)
}
inline ::BrightnessEffectConfig* EffectProto::_internal_mutable_brightness() {
  if (!_internal_has_brightness()) {
    clear_effect();
    set_has_brightness();
    effect_.brightness_ = CreateMaybeMessage< ::BrightnessEffectConfig >(GetArena());
  }
  return effect_.brightness_;
}
inline ::BrightnessEffectConfig* EffectProto::mutable_brightness() {
  // @@protoc_insertion_point(field_mutable:EffectProto.brightness)
  return _internal_mutable_brightness();
}

// .HueEffectConfig hue = 5;
inline bool EffectProto::_internal_has_hue() const {
  return effect_case() == kHue;
}
inline bool EffectProto::has_hue() const {
  return _internal_has_hue();
}
inline void EffectProto::set_has_hue() {
  _oneof_case_[0] = kHue;
}
inline void EffectProto::clear_hue() {
  if (_internal_has_hue()) {
    if (GetArena() == nullptr) {
      delete effect_.hue_;
    }
    clear_has_effect();
  }
}
inline ::HueEffectConfig* EffectProto::release_hue() {
  // @@protoc_insertion_point(field_release:EffectProto.hue)
  if (_internal_has_hue()) {
    clear_has_effect();
      ::HueEffectConfig* temp = effect_.hue_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    effect_.hue_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::HueEffectConfig& EffectProto::_internal_hue() const {
  return _internal_has_hue()
      ? *effect_.hue_
      : reinterpret_cast< ::HueEffectConfig&>(::_HueEffectConfig_default_instance_);
}
inline const ::HueEffectConfig& EffectProto::hue() const {
  // @@protoc_insertion_point(field_get:EffectProto.hue)
  return _internal_hue();
}
inline ::HueEffectConfig* EffectProto::unsafe_arena_release_hue() {
  // @@protoc_insertion_point(field_unsafe_arena_release:EffectProto.hue)
  if (_internal_has_hue()) {
    clear_has_effect();
    ::HueEffectConfig* temp = effect_.hue_;
    effect_.hue_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EffectProto::unsafe_arena_set_allocated_hue(::HueEffectConfig* hue) {
  clear_effect();
  if (hue) {
    set_has_hue();
    effect_.hue_ = hue;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:EffectProto.hue)
}
inline ::HueEffectConfig* EffectProto::_internal_mutable_hue() {
  if (!_internal_has_hue()) {
    clear_effect();
    set_has_hue();
    effect_.hue_ = CreateMaybeMessage< ::HueEffectConfig >(GetArena());
  }
  return effect_.hue_;
}
inline ::HueEffectConfig* EffectProto::mutable_hue() {
  // @@protoc_insertion_point(field_mutable:EffectProto.hue)
  return _internal_mutable_hue();
}

// .SaturationEffectConfig saturation = 6;
inline bool EffectProto::_internal_has_saturation() const {
  return effect_case() == kSaturation;
}
inline bool EffectProto::has_saturation() const {
  return _internal_has_saturation();
}
inline void EffectProto::set_has_saturation() {
  _oneof_case_[0] = kSaturation;
}
inline void EffectProto::clear_saturation() {
  if (_internal_has_saturation()) {
    if (GetArena() == nullptr) {
      delete effect_.saturation_;
    }
    clear_has_effect();
  }
}
inline ::SaturationEffectConfig* EffectProto::release_saturation() {
  // @@protoc_insertion_point(field_release:EffectProto.saturation)
  if (_internal_has_saturation()) {
    clear_has_effect();
      ::SaturationEffectConfig* temp = effect_.saturation_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    effect_.saturation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::SaturationEffectConfig& EffectProto::_internal_saturation() const {
  return _internal_has_saturation()
      ? *effect_.saturation_
      : reinterpret_cast< ::SaturationEffectConfig&>(::_SaturationEffectConfig_default_instance_);
}
inline const ::SaturationEffectConfig& EffectProto::saturation() const {
  // @@protoc_insertion_point(field_get:EffectProto.saturation)
  return _internal_saturation();
}
inline ::SaturationEffectConfig* EffectProto::unsafe_arena_release_saturation() {
  // @@protoc_insertion_point(field_unsafe_arena_release:EffectProto.saturation)
  if (_internal_has_saturation()) {
    clear_has_effect();
    ::SaturationEffectConfig* temp = effect_.saturation_;
    effect_.saturation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void EffectProto::unsafe_arena_set_allocated_saturation(::SaturationEffectConfig* saturation) {
  clear_effect();
  if (saturation) {
    set_has_saturation();
    effect_.saturation_ = saturation;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:EffectProto.saturation)
}
inline ::SaturationEffectConfig* EffectProto::_internal_mutable_saturation() {
  if (!_internal_has_saturation()) {
    clear_effect();
    set_has_saturation();
    effect_.saturation_ = CreateMaybeMessage< ::SaturationEffectConfig >(GetArena());
  }
  return effect_.saturation_;
}
inline ::SaturationEffectConfig* EffectProto::mutable_saturation() {
  // @@protoc_insertion_point(field_mutable:EffectProto.saturation)
  return _internal_mutable_saturation();
}

inline bool EffectProto::has_effect() const {
  return effect_case() != EFFECT_NOT_SET;
}
inline void EffectProto::clear_has_effect() {
  _oneof_case_[0] = EFFECT_NOT_SET;
}
inline EffectProto::EffectCase EffectProto::effect_case() const {
  return EffectProto::EffectCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// AnimationProto

// repeated .EffectProto effects = 1;
inline int AnimationProto::_internal_effects_size() const {
  return effects_.size();
}
inline int AnimationProto::effects_size() const {
  return _internal_effects_size();
}
inline void AnimationProto::clear_effects() {
  effects_.Clear();
}
inline ::EffectProto* AnimationProto::mutable_effects(int index) {
  // @@protoc_insertion_point(field_mutable:AnimationProto.effects)
  return effects_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::EffectProto >*
AnimationProto::mutable_effects() {
  // @@protoc_insertion_point(field_mutable_list:AnimationProto.effects)
  return &effects_;
}
inline const ::EffectProto& AnimationProto::_internal_effects(int index) const {
  return effects_.Get(index);
}
inline const ::EffectProto& AnimationProto::effects(int index) const {
  // @@protoc_insertion_point(field_get:AnimationProto.effects)
  return _internal_effects(index);
}
inline ::EffectProto* AnimationProto::_internal_add_effects() {
  return effects_.Add();
}
inline ::EffectProto* AnimationProto::add_effects() {
  // @@protoc_insertion_point(field_add:AnimationProto.effects)
  return _internal_add_effects();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::EffectProto >&
AnimationProto::effects() const {
  // @@protoc_insertion_point(field_list:AnimationProto.effects)
  return effects_;
}

// uint32 duration_ms = 2;
inline void AnimationProto::clear_duration_ms() {
  duration_ms_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AnimationProto::_internal_duration_ms() const {
  return duration_ms_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AnimationProto::duration_ms() const {
  // @@protoc_insertion_point(field_get:AnimationProto.duration_ms)
  return _internal_duration_ms();
}
inline void AnimationProto::_internal_set_duration_ms(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  duration_ms_ = value;
}
inline void AnimationProto::set_duration_ms(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_duration_ms(value);
  // @@protoc_insertion_point(field_set:AnimationProto.duration_ms)
}

// uint32 num_repeats = 3;
inline void AnimationProto::clear_num_repeats() {
  num_repeats_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AnimationProto::_internal_num_repeats() const {
  return num_repeats_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AnimationProto::num_repeats() const {
  // @@protoc_insertion_point(field_get:AnimationProto.num_repeats)
  return _internal_num_repeats();
}
inline void AnimationProto::_internal_set_num_repeats(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  num_repeats_ = value;
}
inline void AnimationProto::set_num_repeats(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_num_repeats(value);
  // @@protoc_insertion_point(field_set:AnimationProto.num_repeats)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_effects_2eproto
