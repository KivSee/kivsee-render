// source: effects.proto
/**
 * @fileoverview
 * @enhanceable
 * @suppress {messageConventions} JS Compiler reports an error if a variable or
 *     field starts with 'MSG_' and isn't a translatable message.
 * @public
 */
// GENERATED CODE -- DO NOT EDIT!
/* eslint-disable */
// @ts-nocheck

var jspb = require('google-protobuf');
var goog = jspb;
var global = Function('return this')();

var functions_pb = require('./functions_pb.js');
goog.object.extend(proto, functions_pb);
goog.exportSymbol('proto.AnimationProto', null, global);
goog.exportSymbol('proto.BrightnessEffectConfig', null, global);
goog.exportSymbol('proto.ConstColorEffectConfig', null, global);
goog.exportSymbol('proto.EffectConfig', null, global);
goog.exportSymbol('proto.EffectProto', null, global);
goog.exportSymbol('proto.EffectProto.EffectCase', null, global);
goog.exportSymbol('proto.HSV', null, global);
goog.exportSymbol('proto.HueEffectConfig', null, global);
goog.exportSymbol('proto.RainbowEffectConfig', null, global);
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.HSV = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.HSV, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.HSV.displayName = 'proto.HSV';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.ConstColorEffectConfig = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.ConstColorEffectConfig, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.ConstColorEffectConfig.displayName = 'proto.ConstColorEffectConfig';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.RainbowEffectConfig = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.RainbowEffectConfig, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.RainbowEffectConfig.displayName = 'proto.RainbowEffectConfig';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.BrightnessEffectConfig = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.BrightnessEffectConfig, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.BrightnessEffectConfig.displayName = 'proto.BrightnessEffectConfig';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.HueEffectConfig = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.HueEffectConfig, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.HueEffectConfig.displayName = 'proto.HueEffectConfig';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.EffectConfig = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.EffectConfig, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.EffectConfig.displayName = 'proto.EffectConfig';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.EffectProto = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, proto.EffectProto.oneofGroups_);
};
goog.inherits(proto.EffectProto, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.EffectProto.displayName = 'proto.EffectProto';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.AnimationProto = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.AnimationProto.repeatedFields_, null);
};
goog.inherits(proto.AnimationProto, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.AnimationProto.displayName = 'proto.AnimationProto';
}



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.HSV.prototype.toObject = function(opt_includeInstance) {
  return proto.HSV.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.HSV} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.HSV.toObject = function(includeInstance, msg) {
  var f, obj = {
    hue: jspb.Message.getFloatingPointFieldWithDefault(msg, 1, 0.0),
    sat: jspb.Message.getFloatingPointFieldWithDefault(msg, 2, 0.0),
    val: jspb.Message.getFloatingPointFieldWithDefault(msg, 3, 0.0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.HSV}
 */
proto.HSV.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.HSV;
  return proto.HSV.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.HSV} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.HSV}
 */
proto.HSV.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setHue(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setSat(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setVal(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.HSV.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.HSV.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.HSV} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.HSV.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getHue();
  if (f !== 0.0) {
    writer.writeFloat(
      1,
      f
    );
  }
  f = message.getSat();
  if (f !== 0.0) {
    writer.writeFloat(
      2,
      f
    );
  }
  f = message.getVal();
  if (f !== 0.0) {
    writer.writeFloat(
      3,
      f
    );
  }
};


/**
 * optional float hue = 1;
 * @return {number}
 */
proto.HSV.prototype.getHue = function() {
  return /** @type {number} */ (jspb.Message.getFloatingPointFieldWithDefault(this, 1, 0.0));
};


/**
 * @param {number} value
 * @return {!proto.HSV} returns this
 */
proto.HSV.prototype.setHue = function(value) {
  return jspb.Message.setProto3FloatField(this, 1, value);
};


/**
 * optional float sat = 2;
 * @return {number}
 */
proto.HSV.prototype.getSat = function() {
  return /** @type {number} */ (jspb.Message.getFloatingPointFieldWithDefault(this, 2, 0.0));
};


/**
 * @param {number} value
 * @return {!proto.HSV} returns this
 */
proto.HSV.prototype.setSat = function(value) {
  return jspb.Message.setProto3FloatField(this, 2, value);
};


/**
 * optional float val = 3;
 * @return {number}
 */
proto.HSV.prototype.getVal = function() {
  return /** @type {number} */ (jspb.Message.getFloatingPointFieldWithDefault(this, 3, 0.0));
};


/**
 * @param {number} value
 * @return {!proto.HSV} returns this
 */
proto.HSV.prototype.setVal = function(value) {
  return jspb.Message.setProto3FloatField(this, 3, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.ConstColorEffectConfig.prototype.toObject = function(opt_includeInstance) {
  return proto.ConstColorEffectConfig.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.ConstColorEffectConfig} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ConstColorEffectConfig.toObject = function(includeInstance, msg) {
  var f, obj = {
    color: (f = msg.getColor()) && proto.HSV.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.ConstColorEffectConfig}
 */
proto.ConstColorEffectConfig.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.ConstColorEffectConfig;
  return proto.ConstColorEffectConfig.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.ConstColorEffectConfig} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.ConstColorEffectConfig}
 */
proto.ConstColorEffectConfig.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.HSV;
      reader.readMessage(value,proto.HSV.deserializeBinaryFromReader);
      msg.setColor(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.ConstColorEffectConfig.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.ConstColorEffectConfig.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.ConstColorEffectConfig} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ConstColorEffectConfig.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getColor();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.HSV.serializeBinaryToWriter
    );
  }
};


/**
 * optional HSV color = 1;
 * @return {?proto.HSV}
 */
proto.ConstColorEffectConfig.prototype.getColor = function() {
  return /** @type{?proto.HSV} */ (
    jspb.Message.getWrapperField(this, proto.HSV, 1));
};


/**
 * @param {?proto.HSV|undefined} value
 * @return {!proto.ConstColorEffectConfig} returns this
*/
proto.ConstColorEffectConfig.prototype.setColor = function(value) {
  return jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.ConstColorEffectConfig} returns this
 */
proto.ConstColorEffectConfig.prototype.clearColor = function() {
  return this.setColor(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.ConstColorEffectConfig.prototype.hasColor = function() {
  return jspb.Message.getField(this, 1) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.RainbowEffectConfig.prototype.toObject = function(opt_includeInstance) {
  return proto.RainbowEffectConfig.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.RainbowEffectConfig} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.RainbowEffectConfig.toObject = function(includeInstance, msg) {
  var f, obj = {
    hueStart: (f = msg.getHueStart()) && functions_pb.FloatFunction.toObject(includeInstance, f),
    hueEnd: (f = msg.getHueEnd()) && functions_pb.FloatFunction.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.RainbowEffectConfig}
 */
proto.RainbowEffectConfig.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.RainbowEffectConfig;
  return proto.RainbowEffectConfig.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.RainbowEffectConfig} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.RainbowEffectConfig}
 */
proto.RainbowEffectConfig.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new functions_pb.FloatFunction;
      reader.readMessage(value,functions_pb.FloatFunction.deserializeBinaryFromReader);
      msg.setHueStart(value);
      break;
    case 2:
      var value = new functions_pb.FloatFunction;
      reader.readMessage(value,functions_pb.FloatFunction.deserializeBinaryFromReader);
      msg.setHueEnd(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.RainbowEffectConfig.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.RainbowEffectConfig.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.RainbowEffectConfig} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.RainbowEffectConfig.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getHueStart();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      functions_pb.FloatFunction.serializeBinaryToWriter
    );
  }
  f = message.getHueEnd();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      functions_pb.FloatFunction.serializeBinaryToWriter
    );
  }
};


/**
 * optional FloatFunction hue_start = 1;
 * @return {?proto.FloatFunction}
 */
proto.RainbowEffectConfig.prototype.getHueStart = function() {
  return /** @type{?proto.FloatFunction} */ (
    jspb.Message.getWrapperField(this, functions_pb.FloatFunction, 1));
};


/**
 * @param {?proto.FloatFunction|undefined} value
 * @return {!proto.RainbowEffectConfig} returns this
*/
proto.RainbowEffectConfig.prototype.setHueStart = function(value) {
  return jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.RainbowEffectConfig} returns this
 */
proto.RainbowEffectConfig.prototype.clearHueStart = function() {
  return this.setHueStart(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.RainbowEffectConfig.prototype.hasHueStart = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional FloatFunction hue_end = 2;
 * @return {?proto.FloatFunction}
 */
proto.RainbowEffectConfig.prototype.getHueEnd = function() {
  return /** @type{?proto.FloatFunction} */ (
    jspb.Message.getWrapperField(this, functions_pb.FloatFunction, 2));
};


/**
 * @param {?proto.FloatFunction|undefined} value
 * @return {!proto.RainbowEffectConfig} returns this
*/
proto.RainbowEffectConfig.prototype.setHueEnd = function(value) {
  return jspb.Message.setWrapperField(this, 2, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.RainbowEffectConfig} returns this
 */
proto.RainbowEffectConfig.prototype.clearHueEnd = function() {
  return this.setHueEnd(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.RainbowEffectConfig.prototype.hasHueEnd = function() {
  return jspb.Message.getField(this, 2) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.BrightnessEffectConfig.prototype.toObject = function(opt_includeInstance) {
  return proto.BrightnessEffectConfig.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.BrightnessEffectConfig} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.BrightnessEffectConfig.toObject = function(includeInstance, msg) {
  var f, obj = {
    multFactor: (f = msg.getMultFactor()) && functions_pb.FloatFunction.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.BrightnessEffectConfig}
 */
proto.BrightnessEffectConfig.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.BrightnessEffectConfig;
  return proto.BrightnessEffectConfig.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.BrightnessEffectConfig} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.BrightnessEffectConfig}
 */
proto.BrightnessEffectConfig.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new functions_pb.FloatFunction;
      reader.readMessage(value,functions_pb.FloatFunction.deserializeBinaryFromReader);
      msg.setMultFactor(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.BrightnessEffectConfig.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.BrightnessEffectConfig.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.BrightnessEffectConfig} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.BrightnessEffectConfig.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getMultFactor();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      functions_pb.FloatFunction.serializeBinaryToWriter
    );
  }
};


/**
 * optional FloatFunction mult_factor = 1;
 * @return {?proto.FloatFunction}
 */
proto.BrightnessEffectConfig.prototype.getMultFactor = function() {
  return /** @type{?proto.FloatFunction} */ (
    jspb.Message.getWrapperField(this, functions_pb.FloatFunction, 1));
};


/**
 * @param {?proto.FloatFunction|undefined} value
 * @return {!proto.BrightnessEffectConfig} returns this
*/
proto.BrightnessEffectConfig.prototype.setMultFactor = function(value) {
  return jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.BrightnessEffectConfig} returns this
 */
proto.BrightnessEffectConfig.prototype.clearMultFactor = function() {
  return this.setMultFactor(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.BrightnessEffectConfig.prototype.hasMultFactor = function() {
  return jspb.Message.getField(this, 1) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.HueEffectConfig.prototype.toObject = function(opt_includeInstance) {
  return proto.HueEffectConfig.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.HueEffectConfig} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.HueEffectConfig.toObject = function(includeInstance, msg) {
  var f, obj = {
    offsetFactor: (f = msg.getOffsetFactor()) && functions_pb.FloatFunction.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.HueEffectConfig}
 */
proto.HueEffectConfig.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.HueEffectConfig;
  return proto.HueEffectConfig.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.HueEffectConfig} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.HueEffectConfig}
 */
proto.HueEffectConfig.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new functions_pb.FloatFunction;
      reader.readMessage(value,functions_pb.FloatFunction.deserializeBinaryFromReader);
      msg.setOffsetFactor(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.HueEffectConfig.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.HueEffectConfig.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.HueEffectConfig} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.HueEffectConfig.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getOffsetFactor();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      functions_pb.FloatFunction.serializeBinaryToWriter
    );
  }
};


/**
 * optional FloatFunction offset_factor = 1;
 * @return {?proto.FloatFunction}
 */
proto.HueEffectConfig.prototype.getOffsetFactor = function() {
  return /** @type{?proto.FloatFunction} */ (
    jspb.Message.getWrapperField(this, functions_pb.FloatFunction, 1));
};


/**
 * @param {?proto.FloatFunction|undefined} value
 * @return {!proto.HueEffectConfig} returns this
*/
proto.HueEffectConfig.prototype.setOffsetFactor = function(value) {
  return jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.HueEffectConfig} returns this
 */
proto.HueEffectConfig.prototype.clearOffsetFactor = function() {
  return this.setOffsetFactor(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.HueEffectConfig.prototype.hasOffsetFactor = function() {
  return jspb.Message.getField(this, 1) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.EffectConfig.prototype.toObject = function(opt_includeInstance) {
  return proto.EffectConfig.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.EffectConfig} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.EffectConfig.toObject = function(includeInstance, msg) {
  var f, obj = {
    startTime: jspb.Message.getFieldWithDefault(msg, 1, 0),
    endTime: jspb.Message.getFieldWithDefault(msg, 2, 0),
    segments: jspb.Message.getFieldWithDefault(msg, 3, ""),
    repeatNum: jspb.Message.getFloatingPointFieldWithDefault(msg, 4, 0.0),
    repeatStart: jspb.Message.getFloatingPointFieldWithDefault(msg, 5, 0.0),
    repeatEnd: jspb.Message.getFloatingPointFieldWithDefault(msg, 6, 0.0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.EffectConfig}
 */
proto.EffectConfig.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.EffectConfig;
  return proto.EffectConfig.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.EffectConfig} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.EffectConfig}
 */
proto.EffectConfig.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setStartTime(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setEndTime(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setSegments(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setRepeatNum(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setRepeatStart(value);
      break;
    case 6:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setRepeatEnd(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.EffectConfig.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.EffectConfig.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.EffectConfig} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.EffectConfig.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getStartTime();
  if (f !== 0) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = message.getEndTime();
  if (f !== 0) {
    writer.writeUint32(
      2,
      f
    );
  }
  f = message.getSegments();
  if (f.length > 0) {
    writer.writeString(
      3,
      f
    );
  }
  f = message.getRepeatNum();
  if (f !== 0.0) {
    writer.writeFloat(
      4,
      f
    );
  }
  f = message.getRepeatStart();
  if (f !== 0.0) {
    writer.writeFloat(
      5,
      f
    );
  }
  f = message.getRepeatEnd();
  if (f !== 0.0) {
    writer.writeFloat(
      6,
      f
    );
  }
};


/**
 * optional uint32 start_time = 1;
 * @return {number}
 */
proto.EffectConfig.prototype.getStartTime = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/**
 * @param {number} value
 * @return {!proto.EffectConfig} returns this
 */
proto.EffectConfig.prototype.setStartTime = function(value) {
  return jspb.Message.setProto3IntField(this, 1, value);
};


/**
 * optional uint32 end_time = 2;
 * @return {number}
 */
proto.EffectConfig.prototype.getEndTime = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {number} value
 * @return {!proto.EffectConfig} returns this
 */
proto.EffectConfig.prototype.setEndTime = function(value) {
  return jspb.Message.setProto3IntField(this, 2, value);
};


/**
 * optional string segments = 3;
 * @return {string}
 */
proto.EffectConfig.prototype.getSegments = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * @param {string} value
 * @return {!proto.EffectConfig} returns this
 */
proto.EffectConfig.prototype.setSegments = function(value) {
  return jspb.Message.setProto3StringField(this, 3, value);
};


/**
 * optional float repeat_num = 4;
 * @return {number}
 */
proto.EffectConfig.prototype.getRepeatNum = function() {
  return /** @type {number} */ (jspb.Message.getFloatingPointFieldWithDefault(this, 4, 0.0));
};


/**
 * @param {number} value
 * @return {!proto.EffectConfig} returns this
 */
proto.EffectConfig.prototype.setRepeatNum = function(value) {
  return jspb.Message.setProto3FloatField(this, 4, value);
};


/**
 * optional float repeat_start = 5;
 * @return {number}
 */
proto.EffectConfig.prototype.getRepeatStart = function() {
  return /** @type {number} */ (jspb.Message.getFloatingPointFieldWithDefault(this, 5, 0.0));
};


/**
 * @param {number} value
 * @return {!proto.EffectConfig} returns this
 */
proto.EffectConfig.prototype.setRepeatStart = function(value) {
  return jspb.Message.setProto3FloatField(this, 5, value);
};


/**
 * optional float repeat_end = 6;
 * @return {number}
 */
proto.EffectConfig.prototype.getRepeatEnd = function() {
  return /** @type {number} */ (jspb.Message.getFloatingPointFieldWithDefault(this, 6, 0.0));
};


/**
 * @param {number} value
 * @return {!proto.EffectConfig} returns this
 */
proto.EffectConfig.prototype.setRepeatEnd = function(value) {
  return jspb.Message.setProto3FloatField(this, 6, value);
};



/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.EffectProto.oneofGroups_ = [[2,3,4,5]];

/**
 * @enum {number}
 */
proto.EffectProto.EffectCase = {
  EFFECT_NOT_SET: 0,
  CONST_COLOR: 2,
  RAINBOW: 3,
  BRIGHTNESS: 4,
  HUE: 5
};

/**
 * @return {proto.EffectProto.EffectCase}
 */
proto.EffectProto.prototype.getEffectCase = function() {
  return /** @type {proto.EffectProto.EffectCase} */(jspb.Message.computeOneofCase(this, proto.EffectProto.oneofGroups_[0]));
};



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.EffectProto.prototype.toObject = function(opt_includeInstance) {
  return proto.EffectProto.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.EffectProto} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.EffectProto.toObject = function(includeInstance, msg) {
  var f, obj = {
    effectConfig: (f = msg.getEffectConfig()) && proto.EffectConfig.toObject(includeInstance, f),
    constColor: (f = msg.getConstColor()) && proto.ConstColorEffectConfig.toObject(includeInstance, f),
    rainbow: (f = msg.getRainbow()) && proto.RainbowEffectConfig.toObject(includeInstance, f),
    brightness: (f = msg.getBrightness()) && proto.BrightnessEffectConfig.toObject(includeInstance, f),
    hue: (f = msg.getHue()) && proto.HueEffectConfig.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.EffectProto}
 */
proto.EffectProto.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.EffectProto;
  return proto.EffectProto.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.EffectProto} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.EffectProto}
 */
proto.EffectProto.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.EffectConfig;
      reader.readMessage(value,proto.EffectConfig.deserializeBinaryFromReader);
      msg.setEffectConfig(value);
      break;
    case 2:
      var value = new proto.ConstColorEffectConfig;
      reader.readMessage(value,proto.ConstColorEffectConfig.deserializeBinaryFromReader);
      msg.setConstColor(value);
      break;
    case 3:
      var value = new proto.RainbowEffectConfig;
      reader.readMessage(value,proto.RainbowEffectConfig.deserializeBinaryFromReader);
      msg.setRainbow(value);
      break;
    case 4:
      var value = new proto.BrightnessEffectConfig;
      reader.readMessage(value,proto.BrightnessEffectConfig.deserializeBinaryFromReader);
      msg.setBrightness(value);
      break;
    case 5:
      var value = new proto.HueEffectConfig;
      reader.readMessage(value,proto.HueEffectConfig.deserializeBinaryFromReader);
      msg.setHue(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.EffectProto.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.EffectProto.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.EffectProto} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.EffectProto.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getEffectConfig();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.EffectConfig.serializeBinaryToWriter
    );
  }
  f = message.getConstColor();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.ConstColorEffectConfig.serializeBinaryToWriter
    );
  }
  f = message.getRainbow();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.RainbowEffectConfig.serializeBinaryToWriter
    );
  }
  f = message.getBrightness();
  if (f != null) {
    writer.writeMessage(
      4,
      f,
      proto.BrightnessEffectConfig.serializeBinaryToWriter
    );
  }
  f = message.getHue();
  if (f != null) {
    writer.writeMessage(
      5,
      f,
      proto.HueEffectConfig.serializeBinaryToWriter
    );
  }
};


/**
 * optional EffectConfig effect_config = 1;
 * @return {?proto.EffectConfig}
 */
proto.EffectProto.prototype.getEffectConfig = function() {
  return /** @type{?proto.EffectConfig} */ (
    jspb.Message.getWrapperField(this, proto.EffectConfig, 1));
};


/**
 * @param {?proto.EffectConfig|undefined} value
 * @return {!proto.EffectProto} returns this
*/
proto.EffectProto.prototype.setEffectConfig = function(value) {
  return jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.EffectProto} returns this
 */
proto.EffectProto.prototype.clearEffectConfig = function() {
  return this.setEffectConfig(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.EffectProto.prototype.hasEffectConfig = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional ConstColorEffectConfig const_color = 2;
 * @return {?proto.ConstColorEffectConfig}
 */
proto.EffectProto.prototype.getConstColor = function() {
  return /** @type{?proto.ConstColorEffectConfig} */ (
    jspb.Message.getWrapperField(this, proto.ConstColorEffectConfig, 2));
};


/**
 * @param {?proto.ConstColorEffectConfig|undefined} value
 * @return {!proto.EffectProto} returns this
*/
proto.EffectProto.prototype.setConstColor = function(value) {
  return jspb.Message.setOneofWrapperField(this, 2, proto.EffectProto.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.EffectProto} returns this
 */
proto.EffectProto.prototype.clearConstColor = function() {
  return this.setConstColor(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.EffectProto.prototype.hasConstColor = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional RainbowEffectConfig rainbow = 3;
 * @return {?proto.RainbowEffectConfig}
 */
proto.EffectProto.prototype.getRainbow = function() {
  return /** @type{?proto.RainbowEffectConfig} */ (
    jspb.Message.getWrapperField(this, proto.RainbowEffectConfig, 3));
};


/**
 * @param {?proto.RainbowEffectConfig|undefined} value
 * @return {!proto.EffectProto} returns this
*/
proto.EffectProto.prototype.setRainbow = function(value) {
  return jspb.Message.setOneofWrapperField(this, 3, proto.EffectProto.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.EffectProto} returns this
 */
proto.EffectProto.prototype.clearRainbow = function() {
  return this.setRainbow(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.EffectProto.prototype.hasRainbow = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional BrightnessEffectConfig brightness = 4;
 * @return {?proto.BrightnessEffectConfig}
 */
proto.EffectProto.prototype.getBrightness = function() {
  return /** @type{?proto.BrightnessEffectConfig} */ (
    jspb.Message.getWrapperField(this, proto.BrightnessEffectConfig, 4));
};


/**
 * @param {?proto.BrightnessEffectConfig|undefined} value
 * @return {!proto.EffectProto} returns this
*/
proto.EffectProto.prototype.setBrightness = function(value) {
  return jspb.Message.setOneofWrapperField(this, 4, proto.EffectProto.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.EffectProto} returns this
 */
proto.EffectProto.prototype.clearBrightness = function() {
  return this.setBrightness(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.EffectProto.prototype.hasBrightness = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional HueEffectConfig hue = 5;
 * @return {?proto.HueEffectConfig}
 */
proto.EffectProto.prototype.getHue = function() {
  return /** @type{?proto.HueEffectConfig} */ (
    jspb.Message.getWrapperField(this, proto.HueEffectConfig, 5));
};


/**
 * @param {?proto.HueEffectConfig|undefined} value
 * @return {!proto.EffectProto} returns this
*/
proto.EffectProto.prototype.setHue = function(value) {
  return jspb.Message.setOneofWrapperField(this, 5, proto.EffectProto.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.EffectProto} returns this
 */
proto.EffectProto.prototype.clearHue = function() {
  return this.setHue(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.EffectProto.prototype.hasHue = function() {
  return jspb.Message.getField(this, 5) != null;
};



/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.AnimationProto.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.AnimationProto.prototype.toObject = function(opt_includeInstance) {
  return proto.AnimationProto.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.AnimationProto} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.AnimationProto.toObject = function(includeInstance, msg) {
  var f, obj = {
    effectsList: jspb.Message.toObjectList(msg.getEffectsList(),
    proto.EffectProto.toObject, includeInstance),
    durationMs: jspb.Message.getFieldWithDefault(msg, 2, 0),
    numRepeats: jspb.Message.getFieldWithDefault(msg, 3, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.AnimationProto}
 */
proto.AnimationProto.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.AnimationProto;
  return proto.AnimationProto.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.AnimationProto} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.AnimationProto}
 */
proto.AnimationProto.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.EffectProto;
      reader.readMessage(value,proto.EffectProto.deserializeBinaryFromReader);
      msg.addEffects(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setDurationMs(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setNumRepeats(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.AnimationProto.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.AnimationProto.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.AnimationProto} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.AnimationProto.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getEffectsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1,
      f,
      proto.EffectProto.serializeBinaryToWriter
    );
  }
  f = message.getDurationMs();
  if (f !== 0) {
    writer.writeUint32(
      2,
      f
    );
  }
  f = message.getNumRepeats();
  if (f !== 0) {
    writer.writeUint32(
      3,
      f
    );
  }
};


/**
 * repeated EffectProto effects = 1;
 * @return {!Array<!proto.EffectProto>}
 */
proto.AnimationProto.prototype.getEffectsList = function() {
  return /** @type{!Array<!proto.EffectProto>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.EffectProto, 1));
};


/**
 * @param {!Array<!proto.EffectProto>} value
 * @return {!proto.AnimationProto} returns this
*/
proto.AnimationProto.prototype.setEffectsList = function(value) {
  return jspb.Message.setRepeatedWrapperField(this, 1, value);
};


/**
 * @param {!proto.EffectProto=} opt_value
 * @param {number=} opt_index
 * @return {!proto.EffectProto}
 */
proto.AnimationProto.prototype.addEffects = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.EffectProto, opt_index);
};


/**
 * Clears the list making it empty but non-null.
 * @return {!proto.AnimationProto} returns this
 */
proto.AnimationProto.prototype.clearEffectsList = function() {
  return this.setEffectsList([]);
};


/**
 * optional uint32 duration_ms = 2;
 * @return {number}
 */
proto.AnimationProto.prototype.getDurationMs = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/**
 * @param {number} value
 * @return {!proto.AnimationProto} returns this
 */
proto.AnimationProto.prototype.setDurationMs = function(value) {
  return jspb.Message.setProto3IntField(this, 2, value);
};


/**
 * optional uint32 num_repeats = 3;
 * @return {number}
 */
proto.AnimationProto.prototype.getNumRepeats = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/**
 * @param {number} value
 * @return {!proto.AnimationProto} returns this
 */
proto.AnimationProto.prototype.setNumRepeats = function(value) {
  return jspb.Message.setProto3IntField(this, 3, value);
};


goog.object.extend(exports, proto);
