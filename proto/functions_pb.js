// source: functions.proto
/**
 * @fileoverview
 * @enhanceable
 * @suppress {messageConventions} JS Compiler reports an error if a variable or
 *     field starts with 'MSG_' and isn't a translatable message.
 * @public
 */
// GENERATED CODE -- DO NOT EDIT!
/* eslint-disable */
// @ts-nocheck

var jspb = require('google-protobuf');
var goog = jspb;
var global = Function('return this')();

goog.exportSymbol('proto.Comb2FloatFunctionConfig', null, global);
goog.exportSymbol('proto.ConstValueFloatFunctionConfig', null, global);
goog.exportSymbol('proto.FloatFunction', null, global);
goog.exportSymbol('proto.FloatFunction.FunctionCase', null, global);
goog.exportSymbol('proto.HalfFloatFunctionConfig', null, global);
goog.exportSymbol('proto.LinearFloatFunctionConfig', null, global);
goog.exportSymbol('proto.RepeatFloatFunctionConfig', null, global);
goog.exportSymbol('proto.SinFloatFunctionConfig', null, global);
goog.exportSymbol('proto.StepsFloatFunctionConfig', null, global);
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.ConstValueFloatFunctionConfig = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.ConstValueFloatFunctionConfig, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.ConstValueFloatFunctionConfig.displayName = 'proto.ConstValueFloatFunctionConfig';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.LinearFloatFunctionConfig = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.LinearFloatFunctionConfig, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.LinearFloatFunctionConfig.displayName = 'proto.LinearFloatFunctionConfig';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SinFloatFunctionConfig = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SinFloatFunctionConfig, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.SinFloatFunctionConfig.displayName = 'proto.SinFloatFunctionConfig';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.StepsFloatFunctionConfig = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.StepsFloatFunctionConfig, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.StepsFloatFunctionConfig.displayName = 'proto.StepsFloatFunctionConfig';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.RepeatFloatFunctionConfig = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.RepeatFloatFunctionConfig, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.RepeatFloatFunctionConfig.displayName = 'proto.RepeatFloatFunctionConfig';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.HalfFloatFunctionConfig = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.HalfFloatFunctionConfig, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.HalfFloatFunctionConfig.displayName = 'proto.HalfFloatFunctionConfig';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.Comb2FloatFunctionConfig = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.Comb2FloatFunctionConfig, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.Comb2FloatFunctionConfig.displayName = 'proto.Comb2FloatFunctionConfig';
}
/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.FloatFunction = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, proto.FloatFunction.oneofGroups_);
};
goog.inherits(proto.FloatFunction, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  /**
   * @public
   * @override
   */
  proto.FloatFunction.displayName = 'proto.FloatFunction';
}



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.ConstValueFloatFunctionConfig.prototype.toObject = function(opt_includeInstance) {
  return proto.ConstValueFloatFunctionConfig.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.ConstValueFloatFunctionConfig} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ConstValueFloatFunctionConfig.toObject = function(includeInstance, msg) {
  var f, obj = {
    value: jspb.Message.getFloatingPointFieldWithDefault(msg, 1, 0.0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.ConstValueFloatFunctionConfig}
 */
proto.ConstValueFloatFunctionConfig.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.ConstValueFloatFunctionConfig;
  return proto.ConstValueFloatFunctionConfig.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.ConstValueFloatFunctionConfig} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.ConstValueFloatFunctionConfig}
 */
proto.ConstValueFloatFunctionConfig.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setValue(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.ConstValueFloatFunctionConfig.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.ConstValueFloatFunctionConfig.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.ConstValueFloatFunctionConfig} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ConstValueFloatFunctionConfig.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getValue();
  if (f !== 0.0) {
    writer.writeFloat(
      1,
      f
    );
  }
};


/**
 * optional float value = 1;
 * @return {number}
 */
proto.ConstValueFloatFunctionConfig.prototype.getValue = function() {
  return /** @type {number} */ (jspb.Message.getFloatingPointFieldWithDefault(this, 1, 0.0));
};


/**
 * @param {number} value
 * @return {!proto.ConstValueFloatFunctionConfig} returns this
 */
proto.ConstValueFloatFunctionConfig.prototype.setValue = function(value) {
  return jspb.Message.setProto3FloatField(this, 1, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.LinearFloatFunctionConfig.prototype.toObject = function(opt_includeInstance) {
  return proto.LinearFloatFunctionConfig.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.LinearFloatFunctionConfig} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.LinearFloatFunctionConfig.toObject = function(includeInstance, msg) {
  var f, obj = {
    start: jspb.Message.getFloatingPointFieldWithDefault(msg, 1, 0.0),
    end: jspb.Message.getFloatingPointFieldWithDefault(msg, 2, 0.0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.LinearFloatFunctionConfig}
 */
proto.LinearFloatFunctionConfig.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.LinearFloatFunctionConfig;
  return proto.LinearFloatFunctionConfig.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.LinearFloatFunctionConfig} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.LinearFloatFunctionConfig}
 */
proto.LinearFloatFunctionConfig.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setStart(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setEnd(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.LinearFloatFunctionConfig.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.LinearFloatFunctionConfig.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.LinearFloatFunctionConfig} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.LinearFloatFunctionConfig.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getStart();
  if (f !== 0.0) {
    writer.writeFloat(
      1,
      f
    );
  }
  f = message.getEnd();
  if (f !== 0.0) {
    writer.writeFloat(
      2,
      f
    );
  }
};


/**
 * optional float start = 1;
 * @return {number}
 */
proto.LinearFloatFunctionConfig.prototype.getStart = function() {
  return /** @type {number} */ (jspb.Message.getFloatingPointFieldWithDefault(this, 1, 0.0));
};


/**
 * @param {number} value
 * @return {!proto.LinearFloatFunctionConfig} returns this
 */
proto.LinearFloatFunctionConfig.prototype.setStart = function(value) {
  return jspb.Message.setProto3FloatField(this, 1, value);
};


/**
 * optional float end = 2;
 * @return {number}
 */
proto.LinearFloatFunctionConfig.prototype.getEnd = function() {
  return /** @type {number} */ (jspb.Message.getFloatingPointFieldWithDefault(this, 2, 0.0));
};


/**
 * @param {number} value
 * @return {!proto.LinearFloatFunctionConfig} returns this
 */
proto.LinearFloatFunctionConfig.prototype.setEnd = function(value) {
  return jspb.Message.setProto3FloatField(this, 2, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SinFloatFunctionConfig.prototype.toObject = function(opt_includeInstance) {
  return proto.SinFloatFunctionConfig.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SinFloatFunctionConfig} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SinFloatFunctionConfig.toObject = function(includeInstance, msg) {
  var f, obj = {
    min: jspb.Message.getFloatingPointFieldWithDefault(msg, 1, 0.0),
    max: jspb.Message.getFloatingPointFieldWithDefault(msg, 2, 0.0),
    phase: jspb.Message.getFloatingPointFieldWithDefault(msg, 3, 0.0),
    repeats: jspb.Message.getFloatingPointFieldWithDefault(msg, 4, 0.0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SinFloatFunctionConfig}
 */
proto.SinFloatFunctionConfig.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SinFloatFunctionConfig;
  return proto.SinFloatFunctionConfig.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SinFloatFunctionConfig} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SinFloatFunctionConfig}
 */
proto.SinFloatFunctionConfig.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setMin(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setMax(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setPhase(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setRepeats(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SinFloatFunctionConfig.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SinFloatFunctionConfig.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SinFloatFunctionConfig} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SinFloatFunctionConfig.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getMin();
  if (f !== 0.0) {
    writer.writeFloat(
      1,
      f
    );
  }
  f = message.getMax();
  if (f !== 0.0) {
    writer.writeFloat(
      2,
      f
    );
  }
  f = message.getPhase();
  if (f !== 0.0) {
    writer.writeFloat(
      3,
      f
    );
  }
  f = message.getRepeats();
  if (f !== 0.0) {
    writer.writeFloat(
      4,
      f
    );
  }
};


/**
 * optional float min = 1;
 * @return {number}
 */
proto.SinFloatFunctionConfig.prototype.getMin = function() {
  return /** @type {number} */ (jspb.Message.getFloatingPointFieldWithDefault(this, 1, 0.0));
};


/**
 * @param {number} value
 * @return {!proto.SinFloatFunctionConfig} returns this
 */
proto.SinFloatFunctionConfig.prototype.setMin = function(value) {
  return jspb.Message.setProto3FloatField(this, 1, value);
};


/**
 * optional float max = 2;
 * @return {number}
 */
proto.SinFloatFunctionConfig.prototype.getMax = function() {
  return /** @type {number} */ (jspb.Message.getFloatingPointFieldWithDefault(this, 2, 0.0));
};


/**
 * @param {number} value
 * @return {!proto.SinFloatFunctionConfig} returns this
 */
proto.SinFloatFunctionConfig.prototype.setMax = function(value) {
  return jspb.Message.setProto3FloatField(this, 2, value);
};


/**
 * optional float phase = 3;
 * @return {number}
 */
proto.SinFloatFunctionConfig.prototype.getPhase = function() {
  return /** @type {number} */ (jspb.Message.getFloatingPointFieldWithDefault(this, 3, 0.0));
};


/**
 * @param {number} value
 * @return {!proto.SinFloatFunctionConfig} returns this
 */
proto.SinFloatFunctionConfig.prototype.setPhase = function(value) {
  return jspb.Message.setProto3FloatField(this, 3, value);
};


/**
 * optional float repeats = 4;
 * @return {number}
 */
proto.SinFloatFunctionConfig.prototype.getRepeats = function() {
  return /** @type {number} */ (jspb.Message.getFloatingPointFieldWithDefault(this, 4, 0.0));
};


/**
 * @param {number} value
 * @return {!proto.SinFloatFunctionConfig} returns this
 */
proto.SinFloatFunctionConfig.prototype.setRepeats = function(value) {
  return jspb.Message.setProto3FloatField(this, 4, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.StepsFloatFunctionConfig.prototype.toObject = function(opt_includeInstance) {
  return proto.StepsFloatFunctionConfig.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.StepsFloatFunctionConfig} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.StepsFloatFunctionConfig.toObject = function(includeInstance, msg) {
  var f, obj = {
    numSteps: jspb.Message.getFloatingPointFieldWithDefault(msg, 1, 0.0),
    diffPerStep: jspb.Message.getFloatingPointFieldWithDefault(msg, 2, 0.0),
    firstStepValue: jspb.Message.getFloatingPointFieldWithDefault(msg, 3, 0.0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.StepsFloatFunctionConfig}
 */
proto.StepsFloatFunctionConfig.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.StepsFloatFunctionConfig;
  return proto.StepsFloatFunctionConfig.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.StepsFloatFunctionConfig} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.StepsFloatFunctionConfig}
 */
proto.StepsFloatFunctionConfig.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setNumSteps(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setDiffPerStep(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setFirstStepValue(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.StepsFloatFunctionConfig.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.StepsFloatFunctionConfig.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.StepsFloatFunctionConfig} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.StepsFloatFunctionConfig.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getNumSteps();
  if (f !== 0.0) {
    writer.writeFloat(
      1,
      f
    );
  }
  f = message.getDiffPerStep();
  if (f !== 0.0) {
    writer.writeFloat(
      2,
      f
    );
  }
  f = message.getFirstStepValue();
  if (f !== 0.0) {
    writer.writeFloat(
      3,
      f
    );
  }
};


/**
 * optional float num_steps = 1;
 * @return {number}
 */
proto.StepsFloatFunctionConfig.prototype.getNumSteps = function() {
  return /** @type {number} */ (jspb.Message.getFloatingPointFieldWithDefault(this, 1, 0.0));
};


/**
 * @param {number} value
 * @return {!proto.StepsFloatFunctionConfig} returns this
 */
proto.StepsFloatFunctionConfig.prototype.setNumSteps = function(value) {
  return jspb.Message.setProto3FloatField(this, 1, value);
};


/**
 * optional float diff_per_step = 2;
 * @return {number}
 */
proto.StepsFloatFunctionConfig.prototype.getDiffPerStep = function() {
  return /** @type {number} */ (jspb.Message.getFloatingPointFieldWithDefault(this, 2, 0.0));
};


/**
 * @param {number} value
 * @return {!proto.StepsFloatFunctionConfig} returns this
 */
proto.StepsFloatFunctionConfig.prototype.setDiffPerStep = function(value) {
  return jspb.Message.setProto3FloatField(this, 2, value);
};


/**
 * optional float first_step_value = 3;
 * @return {number}
 */
proto.StepsFloatFunctionConfig.prototype.getFirstStepValue = function() {
  return /** @type {number} */ (jspb.Message.getFloatingPointFieldWithDefault(this, 3, 0.0));
};


/**
 * @param {number} value
 * @return {!proto.StepsFloatFunctionConfig} returns this
 */
proto.StepsFloatFunctionConfig.prototype.setFirstStepValue = function(value) {
  return jspb.Message.setProto3FloatField(this, 3, value);
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.RepeatFloatFunctionConfig.prototype.toObject = function(opt_includeInstance) {
  return proto.RepeatFloatFunctionConfig.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.RepeatFloatFunctionConfig} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.RepeatFloatFunctionConfig.toObject = function(includeInstance, msg) {
  var f, obj = {
    numberoftimes: jspb.Message.getFloatingPointFieldWithDefault(msg, 1, 0.0),
    functorepeat: (f = msg.getFunctorepeat()) && proto.FloatFunction.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.RepeatFloatFunctionConfig}
 */
proto.RepeatFloatFunctionConfig.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.RepeatFloatFunctionConfig;
  return proto.RepeatFloatFunctionConfig.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.RepeatFloatFunctionConfig} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.RepeatFloatFunctionConfig}
 */
proto.RepeatFloatFunctionConfig.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setNumberoftimes(value);
      break;
    case 2:
      var value = new proto.FloatFunction;
      reader.readMessage(value,proto.FloatFunction.deserializeBinaryFromReader);
      msg.setFunctorepeat(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.RepeatFloatFunctionConfig.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.RepeatFloatFunctionConfig.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.RepeatFloatFunctionConfig} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.RepeatFloatFunctionConfig.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getNumberoftimes();
  if (f !== 0.0) {
    writer.writeFloat(
      1,
      f
    );
  }
  f = message.getFunctorepeat();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.FloatFunction.serializeBinaryToWriter
    );
  }
};


/**
 * optional float numberOfTimes = 1;
 * @return {number}
 */
proto.RepeatFloatFunctionConfig.prototype.getNumberoftimes = function() {
  return /** @type {number} */ (jspb.Message.getFloatingPointFieldWithDefault(this, 1, 0.0));
};


/**
 * @param {number} value
 * @return {!proto.RepeatFloatFunctionConfig} returns this
 */
proto.RepeatFloatFunctionConfig.prototype.setNumberoftimes = function(value) {
  return jspb.Message.setProto3FloatField(this, 1, value);
};


/**
 * optional FloatFunction funcToRepeat = 2;
 * @return {?proto.FloatFunction}
 */
proto.RepeatFloatFunctionConfig.prototype.getFunctorepeat = function() {
  return /** @type{?proto.FloatFunction} */ (
    jspb.Message.getWrapperField(this, proto.FloatFunction, 2));
};


/**
 * @param {?proto.FloatFunction|undefined} value
 * @return {!proto.RepeatFloatFunctionConfig} returns this
*/
proto.RepeatFloatFunctionConfig.prototype.setFunctorepeat = function(value) {
  return jspb.Message.setWrapperField(this, 2, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.RepeatFloatFunctionConfig} returns this
 */
proto.RepeatFloatFunctionConfig.prototype.clearFunctorepeat = function() {
  return this.setFunctorepeat(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.RepeatFloatFunctionConfig.prototype.hasFunctorepeat = function() {
  return jspb.Message.getField(this, 2) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.HalfFloatFunctionConfig.prototype.toObject = function(opt_includeInstance) {
  return proto.HalfFloatFunctionConfig.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.HalfFloatFunctionConfig} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.HalfFloatFunctionConfig.toObject = function(includeInstance, msg) {
  var f, obj = {
    f1: (f = msg.getF1()) && proto.FloatFunction.toObject(includeInstance, f),
    f2: (f = msg.getF2()) && proto.FloatFunction.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.HalfFloatFunctionConfig}
 */
proto.HalfFloatFunctionConfig.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.HalfFloatFunctionConfig;
  return proto.HalfFloatFunctionConfig.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.HalfFloatFunctionConfig} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.HalfFloatFunctionConfig}
 */
proto.HalfFloatFunctionConfig.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.FloatFunction;
      reader.readMessage(value,proto.FloatFunction.deserializeBinaryFromReader);
      msg.setF1(value);
      break;
    case 2:
      var value = new proto.FloatFunction;
      reader.readMessage(value,proto.FloatFunction.deserializeBinaryFromReader);
      msg.setF2(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.HalfFloatFunctionConfig.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.HalfFloatFunctionConfig.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.HalfFloatFunctionConfig} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.HalfFloatFunctionConfig.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getF1();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.FloatFunction.serializeBinaryToWriter
    );
  }
  f = message.getF2();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.FloatFunction.serializeBinaryToWriter
    );
  }
};


/**
 * optional FloatFunction f1 = 1;
 * @return {?proto.FloatFunction}
 */
proto.HalfFloatFunctionConfig.prototype.getF1 = function() {
  return /** @type{?proto.FloatFunction} */ (
    jspb.Message.getWrapperField(this, proto.FloatFunction, 1));
};


/**
 * @param {?proto.FloatFunction|undefined} value
 * @return {!proto.HalfFloatFunctionConfig} returns this
*/
proto.HalfFloatFunctionConfig.prototype.setF1 = function(value) {
  return jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.HalfFloatFunctionConfig} returns this
 */
proto.HalfFloatFunctionConfig.prototype.clearF1 = function() {
  return this.setF1(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.HalfFloatFunctionConfig.prototype.hasF1 = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional FloatFunction f2 = 2;
 * @return {?proto.FloatFunction}
 */
proto.HalfFloatFunctionConfig.prototype.getF2 = function() {
  return /** @type{?proto.FloatFunction} */ (
    jspb.Message.getWrapperField(this, proto.FloatFunction, 2));
};


/**
 * @param {?proto.FloatFunction|undefined} value
 * @return {!proto.HalfFloatFunctionConfig} returns this
*/
proto.HalfFloatFunctionConfig.prototype.setF2 = function(value) {
  return jspb.Message.setWrapperField(this, 2, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.HalfFloatFunctionConfig} returns this
 */
proto.HalfFloatFunctionConfig.prototype.clearF2 = function() {
  return this.setF2(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.HalfFloatFunctionConfig.prototype.hasF2 = function() {
  return jspb.Message.getField(this, 2) != null;
};





if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.Comb2FloatFunctionConfig.prototype.toObject = function(opt_includeInstance) {
  return proto.Comb2FloatFunctionConfig.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.Comb2FloatFunctionConfig} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.Comb2FloatFunctionConfig.toObject = function(includeInstance, msg) {
  var f, obj = {
    f1: (f = msg.getF1()) && proto.FloatFunction.toObject(includeInstance, f),
    amount1: jspb.Message.getFloatingPointFieldWithDefault(msg, 2, 0.0),
    f2: (f = msg.getF2()) && proto.FloatFunction.toObject(includeInstance, f),
    amount2: jspb.Message.getFloatingPointFieldWithDefault(msg, 4, 0.0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.Comb2FloatFunctionConfig}
 */
proto.Comb2FloatFunctionConfig.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.Comb2FloatFunctionConfig;
  return proto.Comb2FloatFunctionConfig.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.Comb2FloatFunctionConfig} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.Comb2FloatFunctionConfig}
 */
proto.Comb2FloatFunctionConfig.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.FloatFunction;
      reader.readMessage(value,proto.FloatFunction.deserializeBinaryFromReader);
      msg.setF1(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setAmount1(value);
      break;
    case 3:
      var value = new proto.FloatFunction;
      reader.readMessage(value,proto.FloatFunction.deserializeBinaryFromReader);
      msg.setF2(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readFloat());
      msg.setAmount2(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.Comb2FloatFunctionConfig.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.Comb2FloatFunctionConfig.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.Comb2FloatFunctionConfig} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.Comb2FloatFunctionConfig.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getF1();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.FloatFunction.serializeBinaryToWriter
    );
  }
  f = message.getAmount1();
  if (f !== 0.0) {
    writer.writeFloat(
      2,
      f
    );
  }
  f = message.getF2();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.FloatFunction.serializeBinaryToWriter
    );
  }
  f = message.getAmount2();
  if (f !== 0.0) {
    writer.writeFloat(
      4,
      f
    );
  }
};


/**
 * optional FloatFunction f1 = 1;
 * @return {?proto.FloatFunction}
 */
proto.Comb2FloatFunctionConfig.prototype.getF1 = function() {
  return /** @type{?proto.FloatFunction} */ (
    jspb.Message.getWrapperField(this, proto.FloatFunction, 1));
};


/**
 * @param {?proto.FloatFunction|undefined} value
 * @return {!proto.Comb2FloatFunctionConfig} returns this
*/
proto.Comb2FloatFunctionConfig.prototype.setF1 = function(value) {
  return jspb.Message.setWrapperField(this, 1, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.Comb2FloatFunctionConfig} returns this
 */
proto.Comb2FloatFunctionConfig.prototype.clearF1 = function() {
  return this.setF1(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.Comb2FloatFunctionConfig.prototype.hasF1 = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional float amount1 = 2;
 * @return {number}
 */
proto.Comb2FloatFunctionConfig.prototype.getAmount1 = function() {
  return /** @type {number} */ (jspb.Message.getFloatingPointFieldWithDefault(this, 2, 0.0));
};


/**
 * @param {number} value
 * @return {!proto.Comb2FloatFunctionConfig} returns this
 */
proto.Comb2FloatFunctionConfig.prototype.setAmount1 = function(value) {
  return jspb.Message.setProto3FloatField(this, 2, value);
};


/**
 * optional FloatFunction f2 = 3;
 * @return {?proto.FloatFunction}
 */
proto.Comb2FloatFunctionConfig.prototype.getF2 = function() {
  return /** @type{?proto.FloatFunction} */ (
    jspb.Message.getWrapperField(this, proto.FloatFunction, 3));
};


/**
 * @param {?proto.FloatFunction|undefined} value
 * @return {!proto.Comb2FloatFunctionConfig} returns this
*/
proto.Comb2FloatFunctionConfig.prototype.setF2 = function(value) {
  return jspb.Message.setWrapperField(this, 3, value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.Comb2FloatFunctionConfig} returns this
 */
proto.Comb2FloatFunctionConfig.prototype.clearF2 = function() {
  return this.setF2(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.Comb2FloatFunctionConfig.prototype.hasF2 = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional float amount2 = 4;
 * @return {number}
 */
proto.Comb2FloatFunctionConfig.prototype.getAmount2 = function() {
  return /** @type {number} */ (jspb.Message.getFloatingPointFieldWithDefault(this, 4, 0.0));
};


/**
 * @param {number} value
 * @return {!proto.Comb2FloatFunctionConfig} returns this
 */
proto.Comb2FloatFunctionConfig.prototype.setAmount2 = function(value) {
  return jspb.Message.setProto3FloatField(this, 4, value);
};



/**
 * Oneof group definitions for this message. Each group defines the field
 * numbers belonging to that group. When of these fields' value is set, all
 * other fields in the group are cleared. During deserialization, if multiple
 * fields are encountered for a group, only the last value seen will be kept.
 * @private {!Array<!Array<number>>}
 * @const
 */
proto.FloatFunction.oneofGroups_ = [[1,2,3,4,5,6,7]];

/**
 * @enum {number}
 */
proto.FloatFunction.FunctionCase = {
  FUNCTION_NOT_SET: 0,
  CONST_VALUE: 1,
  LINEAR: 2,
  SIN: 3,
  STEPS: 4,
  REPEAT: 5,
  HALF: 6,
  COMB2: 7
};

/**
 * @return {proto.FloatFunction.FunctionCase}
 */
proto.FloatFunction.prototype.getFunctionCase = function() {
  return /** @type {proto.FloatFunction.FunctionCase} */(jspb.Message.computeOneofCase(this, proto.FloatFunction.oneofGroups_[0]));
};



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * Optional fields that are not set will be set to undefined.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     net/proto2/compiler/js/internal/generator.cc#kKeyword.
 * @param {boolean=} opt_includeInstance Deprecated. whether to include the
 *     JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @return {!Object}
 */
proto.FloatFunction.prototype.toObject = function(opt_includeInstance) {
  return proto.FloatFunction.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Deprecated. Whether to include
 *     the JSPB instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.FloatFunction} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.FloatFunction.toObject = function(includeInstance, msg) {
  var f, obj = {
    constValue: (f = msg.getConstValue()) && proto.ConstValueFloatFunctionConfig.toObject(includeInstance, f),
    linear: (f = msg.getLinear()) && proto.LinearFloatFunctionConfig.toObject(includeInstance, f),
    sin: (f = msg.getSin()) && proto.SinFloatFunctionConfig.toObject(includeInstance, f),
    steps: (f = msg.getSteps()) && proto.StepsFloatFunctionConfig.toObject(includeInstance, f),
    repeat: (f = msg.getRepeat()) && proto.RepeatFloatFunctionConfig.toObject(includeInstance, f),
    half: (f = msg.getHalf()) && proto.HalfFloatFunctionConfig.toObject(includeInstance, f),
    comb2: (f = msg.getComb2()) && proto.Comb2FloatFunctionConfig.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.FloatFunction}
 */
proto.FloatFunction.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.FloatFunction;
  return proto.FloatFunction.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.FloatFunction} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.FloatFunction}
 */
proto.FloatFunction.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.ConstValueFloatFunctionConfig;
      reader.readMessage(value,proto.ConstValueFloatFunctionConfig.deserializeBinaryFromReader);
      msg.setConstValue(value);
      break;
    case 2:
      var value = new proto.LinearFloatFunctionConfig;
      reader.readMessage(value,proto.LinearFloatFunctionConfig.deserializeBinaryFromReader);
      msg.setLinear(value);
      break;
    case 3:
      var value = new proto.SinFloatFunctionConfig;
      reader.readMessage(value,proto.SinFloatFunctionConfig.deserializeBinaryFromReader);
      msg.setSin(value);
      break;
    case 4:
      var value = new proto.StepsFloatFunctionConfig;
      reader.readMessage(value,proto.StepsFloatFunctionConfig.deserializeBinaryFromReader);
      msg.setSteps(value);
      break;
    case 5:
      var value = new proto.RepeatFloatFunctionConfig;
      reader.readMessage(value,proto.RepeatFloatFunctionConfig.deserializeBinaryFromReader);
      msg.setRepeat(value);
      break;
    case 6:
      var value = new proto.HalfFloatFunctionConfig;
      reader.readMessage(value,proto.HalfFloatFunctionConfig.deserializeBinaryFromReader);
      msg.setHalf(value);
      break;
    case 7:
      var value = new proto.Comb2FloatFunctionConfig;
      reader.readMessage(value,proto.Comb2FloatFunctionConfig.deserializeBinaryFromReader);
      msg.setComb2(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.FloatFunction.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.FloatFunction.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.FloatFunction} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.FloatFunction.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getConstValue();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.ConstValueFloatFunctionConfig.serializeBinaryToWriter
    );
  }
  f = message.getLinear();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      proto.LinearFloatFunctionConfig.serializeBinaryToWriter
    );
  }
  f = message.getSin();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      proto.SinFloatFunctionConfig.serializeBinaryToWriter
    );
  }
  f = message.getSteps();
  if (f != null) {
    writer.writeMessage(
      4,
      f,
      proto.StepsFloatFunctionConfig.serializeBinaryToWriter
    );
  }
  f = message.getRepeat();
  if (f != null) {
    writer.writeMessage(
      5,
      f,
      proto.RepeatFloatFunctionConfig.serializeBinaryToWriter
    );
  }
  f = message.getHalf();
  if (f != null) {
    writer.writeMessage(
      6,
      f,
      proto.HalfFloatFunctionConfig.serializeBinaryToWriter
    );
  }
  f = message.getComb2();
  if (f != null) {
    writer.writeMessage(
      7,
      f,
      proto.Comb2FloatFunctionConfig.serializeBinaryToWriter
    );
  }
};


/**
 * optional ConstValueFloatFunctionConfig const_value = 1;
 * @return {?proto.ConstValueFloatFunctionConfig}
 */
proto.FloatFunction.prototype.getConstValue = function() {
  return /** @type{?proto.ConstValueFloatFunctionConfig} */ (
    jspb.Message.getWrapperField(this, proto.ConstValueFloatFunctionConfig, 1));
};


/**
 * @param {?proto.ConstValueFloatFunctionConfig|undefined} value
 * @return {!proto.FloatFunction} returns this
*/
proto.FloatFunction.prototype.setConstValue = function(value) {
  return jspb.Message.setOneofWrapperField(this, 1, proto.FloatFunction.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.FloatFunction} returns this
 */
proto.FloatFunction.prototype.clearConstValue = function() {
  return this.setConstValue(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.FloatFunction.prototype.hasConstValue = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional LinearFloatFunctionConfig linear = 2;
 * @return {?proto.LinearFloatFunctionConfig}
 */
proto.FloatFunction.prototype.getLinear = function() {
  return /** @type{?proto.LinearFloatFunctionConfig} */ (
    jspb.Message.getWrapperField(this, proto.LinearFloatFunctionConfig, 2));
};


/**
 * @param {?proto.LinearFloatFunctionConfig|undefined} value
 * @return {!proto.FloatFunction} returns this
*/
proto.FloatFunction.prototype.setLinear = function(value) {
  return jspb.Message.setOneofWrapperField(this, 2, proto.FloatFunction.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.FloatFunction} returns this
 */
proto.FloatFunction.prototype.clearLinear = function() {
  return this.setLinear(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.FloatFunction.prototype.hasLinear = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional SinFloatFunctionConfig sin = 3;
 * @return {?proto.SinFloatFunctionConfig}
 */
proto.FloatFunction.prototype.getSin = function() {
  return /** @type{?proto.SinFloatFunctionConfig} */ (
    jspb.Message.getWrapperField(this, proto.SinFloatFunctionConfig, 3));
};


/**
 * @param {?proto.SinFloatFunctionConfig|undefined} value
 * @return {!proto.FloatFunction} returns this
*/
proto.FloatFunction.prototype.setSin = function(value) {
  return jspb.Message.setOneofWrapperField(this, 3, proto.FloatFunction.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.FloatFunction} returns this
 */
proto.FloatFunction.prototype.clearSin = function() {
  return this.setSin(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.FloatFunction.prototype.hasSin = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional StepsFloatFunctionConfig steps = 4;
 * @return {?proto.StepsFloatFunctionConfig}
 */
proto.FloatFunction.prototype.getSteps = function() {
  return /** @type{?proto.StepsFloatFunctionConfig} */ (
    jspb.Message.getWrapperField(this, proto.StepsFloatFunctionConfig, 4));
};


/**
 * @param {?proto.StepsFloatFunctionConfig|undefined} value
 * @return {!proto.FloatFunction} returns this
*/
proto.FloatFunction.prototype.setSteps = function(value) {
  return jspb.Message.setOneofWrapperField(this, 4, proto.FloatFunction.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.FloatFunction} returns this
 */
proto.FloatFunction.prototype.clearSteps = function() {
  return this.setSteps(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.FloatFunction.prototype.hasSteps = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional RepeatFloatFunctionConfig repeat = 5;
 * @return {?proto.RepeatFloatFunctionConfig}
 */
proto.FloatFunction.prototype.getRepeat = function() {
  return /** @type{?proto.RepeatFloatFunctionConfig} */ (
    jspb.Message.getWrapperField(this, proto.RepeatFloatFunctionConfig, 5));
};


/**
 * @param {?proto.RepeatFloatFunctionConfig|undefined} value
 * @return {!proto.FloatFunction} returns this
*/
proto.FloatFunction.prototype.setRepeat = function(value) {
  return jspb.Message.setOneofWrapperField(this, 5, proto.FloatFunction.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.FloatFunction} returns this
 */
proto.FloatFunction.prototype.clearRepeat = function() {
  return this.setRepeat(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.FloatFunction.prototype.hasRepeat = function() {
  return jspb.Message.getField(this, 5) != null;
};


/**
 * optional HalfFloatFunctionConfig half = 6;
 * @return {?proto.HalfFloatFunctionConfig}
 */
proto.FloatFunction.prototype.getHalf = function() {
  return /** @type{?proto.HalfFloatFunctionConfig} */ (
    jspb.Message.getWrapperField(this, proto.HalfFloatFunctionConfig, 6));
};


/**
 * @param {?proto.HalfFloatFunctionConfig|undefined} value
 * @return {!proto.FloatFunction} returns this
*/
proto.FloatFunction.prototype.setHalf = function(value) {
  return jspb.Message.setOneofWrapperField(this, 6, proto.FloatFunction.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.FloatFunction} returns this
 */
proto.FloatFunction.prototype.clearHalf = function() {
  return this.setHalf(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.FloatFunction.prototype.hasHalf = function() {
  return jspb.Message.getField(this, 6) != null;
};


/**
 * optional Comb2FloatFunctionConfig comb2 = 7;
 * @return {?proto.Comb2FloatFunctionConfig}
 */
proto.FloatFunction.prototype.getComb2 = function() {
  return /** @type{?proto.Comb2FloatFunctionConfig} */ (
    jspb.Message.getWrapperField(this, proto.Comb2FloatFunctionConfig, 7));
};


/**
 * @param {?proto.Comb2FloatFunctionConfig|undefined} value
 * @return {!proto.FloatFunction} returns this
*/
proto.FloatFunction.prototype.setComb2 = function(value) {
  return jspb.Message.setOneofWrapperField(this, 7, proto.FloatFunction.oneofGroups_[0], value);
};


/**
 * Clears the message field making it undefined.
 * @return {!proto.FloatFunction} returns this
 */
proto.FloatFunction.prototype.clearComb2 = function() {
  return this.setComb2(undefined);
};


/**
 * Returns whether this field is set.
 * @return {boolean}
 */
proto.FloatFunction.prototype.hasComb2 = function() {
  return jspb.Message.getField(this, 7) != null;
};


goog.object.extend(exports, proto);
